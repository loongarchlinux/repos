commit 69c30b213fc734ac4b89290e9354dc1304296155
Author: Felix Yan <felixonmars@archlinux.org>
Date:   Mon Jun 21 09:21:42 2021 +0800

    Fix compatibility with GHC 9

diff --git a/rank2classes/rank2classes.cabal b/rank2classes/rank2classes.cabal
index 334ceac..33dbfca 100644
--- a/rank2classes/rank2classes.cabal
+++ b/rank2classes/rank2classes.cabal
@@ -43,7 +43,7 @@ library
                        distributive < 0.7
 
   if flag(use-template-haskell)
-    build-depends: template-haskell >= 2.11 && < 2.17
+    build-depends: template-haskell >= 2.11 && < 2.18
     exposed-modules: Rank2.TH
 
 test-suite doctests
diff --git a/rank2classes/src/Rank2.hs b/rank2classes/src/Rank2.hs
index 26933eb..75a30f9 100644
--- a/rank2classes/src/Rank2.hs
+++ b/rank2classes/src/Rank2.hs
@@ -415,16 +415,16 @@ instance (Apply f, Apply g) => Apply ((Generics.:*:) f g) where
    (x1 Generics.:*: y1) <*> (x2 Generics.:*: y2) = (x1 <*> x2) Generics.:*: (y1 <*> y2)
 
 instance Applicative Empty where
-   pure = const Empty
+   pure _ = Empty
 
 instance Applicative Proxy where
-   pure = const Proxy
+   pure _ = Proxy
 
 instance (Semigroup x, Monoid x) => Applicative (Const x) where
-   pure = const (Const mempty)
+   pure _ = Const mempty
 
 instance Applicative (Only x) where
-   pure = Only
+   pure f = Only f
 
 instance Applicative g => Applicative (Identity g) where
    pure f = Identity (pure f)
diff --git a/rank2classes/src/Rank2/TH.hs b/rank2classes/src/Rank2/TH.hs
index b05d3d4..5f85015 100644
--- a/rank2classes/src/Rank2/TH.hs
+++ b/rank2classes/src/Rank2/TH.hs
@@ -7,6 +7,7 @@
 --
 -- or, if you're picky, you can invoke only 'deriveFunctor' and whichever other instances you need instead.
 
+{-# Language CPP #-}
 {-# Language TemplateHaskell #-}
 -- Adapted from https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial
 
@@ -98,10 +99,17 @@ reifyConstructors cls ty = do
       NewtypeD _ nm tyVars kind c _ -> return (nm, tyVars, kind, [c])
       _ -> fail "deriveApply: tyCon may not be a type synonym."
  
+#if MIN_VERSION_template_haskell(2,17,0)
+   let (KindedTV tyVar () (AppT (AppT ArrowT StarT) StarT)) = last tyVars
+       instanceType           = conT cls `appT` foldl apply (conT tyConName) (init tyVars)
+       apply t (PlainTV name _)    = appT t (varT name)
+       apply t (KindedTV name _ _) = appT t (varT name)
+#else
    let (KindedTV tyVar (AppT (AppT ArrowT StarT) StarT)) = last tyVars
        instanceType           = conT cls `appT` foldl apply (conT tyConName) (init tyVars)
        apply t (PlainTV name)    = appT t (varT name)
        apply t (KindedTV name _) = appT t (varT name)
+#endif
  
    putQ (Deriving tyConName tyVar)
    return (instanceType, cs)
