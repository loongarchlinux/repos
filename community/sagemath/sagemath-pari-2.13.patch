diff --git a/build/pkgs/pari/checksums.ini b/build/pkgs/pari/checksums.ini
index f10b432dbb..ec00516a1d 100644
--- a/build/pkgs/pari/checksums.ini
+++ b/build/pkgs/pari/checksums.ini
@@ -1,5 +1,5 @@
 tarball=pari-VERSION.tar.gz
-sha1=2b9ff51feb388664b834dc346a44867546c78618
-md5=fb2968d7805424518fe44a59a2024afd
-cksum=1247903778
+sha1=40731c850cc50fb4994148fac49fda4f68ce6106
+md5=826064cf75af268be8a482ade6e27501
+cksum=550849474
 upstream_url=https://pari.math.u-bordeaux.fr/pub/pari/unix/pari-VERSION.tar.gz
diff --git a/build/pkgs/pari/package-version.txt b/build/pkgs/pari/package-version.txt
index 25cce6b355..94f15e9cc3 100644
--- a/build/pkgs/pari/package-version.txt
+++ b/build/pkgs/pari/package-version.txt
@@ -1 +1 @@
-2.11.4.p1
+2.13.1
diff --git a/build/pkgs/pari/patches/pari-rnfdisc.patch b/build/pkgs/pari/patches/pari-rnfdisc.patch
new file mode 100644
index 0000000000..3a26e96687
--- /dev/null
+++ b/build/pkgs/pari/patches/pari-rnfdisc.patch
@@ -0,0 +1,19 @@
+From 3edb98db78dd49bb8b4137b46781a7cd570c2556 Mon Sep 17 00:00:00 2001
+From: Bill Allombert <Bill.Allombert@math.u-bordeaux.fr>
+Date: Sun, 28 Mar 2021 13:27:24 +0200
+Subject: [PATCH] rnfdisc_factored: remove spurious Q_primpart [#2284]
+
+diff --git a/src/basemath/base2.c b/src/basemath/base2.c
+index b2b63ada5..531f5c558 100644
+--- a/src/basemath/base2.c
++++ b/src/basemath/base2.c
+@@ -3582,7 +3582,7 @@ rnfdisc_factored(GEN nf, GEN pol, GEN *pd)
+ 
+   nf = checknf(nf);
+   pol = rnfdisc_get_T(nf, pol, &lim);
+-  disc = nf_to_scalar_or_basis(nf, nfX_disc(nf, Q_primpart(pol)));
++  disc = nf_to_scalar_or_basis(nf, nfX_disc(nf, pol));
+   pol = nfX_to_monic(nf, pol, NULL);
+   fa = idealfactor_partial(nf, disc, lim);
+   P = gel(fa,1); l = lg(P);
+
diff --git a/build/pkgs/pari/patches/prot_none_cygwin.patch b/build/pkgs/pari/patches/prot_none_cygwin.patch
index 5cb7438b14..16340dd492 100644
--- a/build/pkgs/pari/patches/prot_none_cygwin.patch
+++ b/build/pkgs/pari/patches/prot_none_cygwin.patch
@@ -3,10 +3,10 @@ Fix pari_mainstack_mreset() on Cygwin
 Rejected upstream because Cygwin is considered a dead platform
 
 diff --git a/src/language/init.c b/src/language/init.c
-index 2d13684..6ea2888 100644
+index 8473a3b..d9993cc 100644
 --- a/src/language/init.c
 +++ b/src/language/init.c
-@@ -653,8 +653,8 @@ pari_mainstack_mfree(void *s, size_t size)
+@@ -884,8 +884,8 @@ pari_mainstack_mfree(void *s, size_t size)
  /* Completely discard the memory mapped between the addresses "from"
   * and "to" (which must be page-aligned).
   *
@@ -17,7 +17,7 @@ index 2d13684..6ea2888 100644
   * still keep the mapping such that we can change the flags to
   * PROT_READ|PROT_WRITE later.
   *
-@@ -662,7 +662,12 @@ pari_mainstack_mfree(void *s, size_t size)
+@@ -893,7 +893,12 @@ pari_mainstack_mfree(void *s, size_t size)
   * calling mprotect(..., PROT_NONE) because the latter will keep the
   * memory committed (this is in particular relevant on Linux with
   * vm.overcommit = 2). This remains true even when calling
@@ -31,15 +31,17 @@ index 2d13684..6ea2888 100644
  static void
  pari_mainstack_mreset(pari_sp from, pari_sp to)
  {
-@@ -671,9 +676,13 @@ pari_mainstack_mreset(pari_sp from, pari_sp to)
+@@ -902,11 +907,15 @@ pari_mainstack_mreset(pari_sp from, pari_sp to)
    if (!s) return;
  
    addr = (void*)from;
 +#ifdef __CYGWIN__
 +  if (mprotect(addr, s, PROT_NONE)) pari_err(e_MEM);
 +#else
+   BLOCK_SIGINT_START;
    res = mmap(addr, s, PROT_NONE,
               MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);
+   BLOCK_SIGINT_END;
    if (res != addr) pari_err(e_MEM);
 +#endif
  }
diff --git a/build/pkgs/pari/spkg-configure.m4 b/build/pkgs/pari/spkg-configure.m4
index 9a1b0c7db8..719b8089ee 100644
--- a/build/pkgs/pari/spkg-configure.m4
+++ b/build/pkgs/pari/spkg-configure.m4
@@ -1,6 +1,6 @@
 SAGE_SPKG_CONFIGURE([pari], [
   dnl See gp_version below on how the version is computed from MAJV.MINV.PATCHV
-  m4_pushdef([SAGE_PARI_MINVER],["133889"])
+  m4_pushdef([SAGE_PARI_MINVER],["134401"])
   SAGE_SPKG_DEPCHECK([gmp mpir readline], [
     AC_PATH_PROG([GP], [gp])
     if test x$GP = x; then dnl GP test
@@ -78,8 +78,8 @@ SAGE_SPKG_CONFIGURE([pari], [
            sage_spkg_install_pari=yes
         fi
         AC_MSG_CHECKING([whether bnfisunit bug of pari 2.11.3 is fixed])
-        bug_check=`echo "bnf = bnfinit(y^4-y-1); bnfisunit(bnf,-y^3+2*y^2-1)" | $GP -qf 2>> config.log`
-        expected="[[0, 2, Mod(0, 2)]]~"
+        bug_check=`echo "bnf = bnfinit(y^4-y-1); bnfisunit(bnf,-y^3+2*y^2-1)==[[0,2,0]]~" | $GP -qf 2>> config.log`
+        expected="1"
         if test x"$bug_check" = x"$expected"; then
            AC_MSG_RESULT([yes])
         else
@@ -99,6 +99,16 @@ SAGE_SPKG_CONFIGURE([pari], [
            AC_MSG_NOTICE([Otherwise Sage will build its own pari/GP.])
            sage_spkg_install_pari=yes
         fi
+        AC_MSG_CHECKING([whether rnfdisc bug of pari 2.13.1 is fixed])
+        bug_check=`echo "K = nfinit(y^4-10*y^2+1); disc = rnfdisc(K,x^2-(y^3/2+y^2-5*y/2+1)); idealnorm(K,disc)" | $GP -qf 2 >> config.log`
+        expected="2304"
+        if test x"$bug_check" = x"$expected"; then
+          AC_MSG_RESULT([yes])
+        else
+           AC_MSG_RESULT([no; cannot use system pari/GP with known bug])
+           AC_MSG_NOTICE([Upgrade your system package and reconfigure.])
+           AC_MSG_NOTICE([Otherwise Sage will build its own pari/GP.])
+        fi
     fi dnl end GP test
 
       if test x$sage_spkg_install_pari = xno; then dnl main PARI test
diff --git a/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/nf_galois_groups.rst b/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/nf_galois_groups.rst
index 07e84de55e..1d78922865 100644
--- a/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/nf_galois_groups.rst
+++ b/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/nf_galois_groups.rst
@@ -305,7 +305,7 @@ ideal classes containing :math:`(5,\sqrt{-30})` and
     sage: category(C)
     Category of finite enumerated commutative groups
     sage: C.gens()
-    (Fractional ideal class (2, a), Fractional ideal class (3, a))
+    (Fractional ideal class (5, a), Fractional ideal class (3, a))
 
 
 Arithmetic in the class group
@@ -322,17 +322,17 @@ means "the product of the 0th and 1st generators of the class group
     sage: K.<a> = QuadraticField(-30)
     sage: C = K.class_group()
     sage: C.0
-    Fractional ideal class (2, a)
+    Fractional ideal class (5, a)
     sage: C.0.ideal()
-    Fractional ideal (2, a)
+    Fractional ideal (5, a)
     sage: I = C.0 * C.1
     sage: I
-    Fractional ideal class (5, a)
+    Fractional ideal class (2, a)
 
 
 Next we find that the class of the fractional ideal
 :math:`(2,\sqrt{-30}+4/3)` is equal to the ideal class
-:math:`C.0`.
+:math:`C.0*C.1`.
 
 .. link
 
@@ -342,7 +342,7 @@ Next we find that the class of the fractional ideal
     sage: J = C(A)
     sage: J
     Fractional ideal class (2/3, 1/3*a)
-    sage: J == C.0
+    sage: J == C.0*C.1
     True
 
 
diff --git a/src/doc/en/thematic_tutorials/sandpile.rst b/src/doc/en/thematic_tutorials/sandpile.rst
index 75ac904ec5..7dd7091415 100644
--- a/src/doc/en/thematic_tutorials/sandpile.rst
+++ b/src/doc/en/thematic_tutorials/sandpile.rst
@@ -324,9 +324,9 @@ sink.
     [1, 1, 3]
     sage: S.reduced_laplacian().dense_matrix().smith_form()
     (
-    [1 0 0]  [ 0  0  1]  [3 1 4]
-    [0 1 0]  [ 1  0  0]  [4 1 6]
-    [0 0 3], [ 0  1 -1], [4 1 5]
+    [1 0 0]  [ 1  0  0]  [1 3 5]
+    [0 1 0]  [ 0  1  0]  [1 4 6]
+    [0 0 3], [ 0 -1  1], [1 4 7]
     )
 
 Adding the identity to any recurrent configuration and stabilizing yields
@@ -687,7 +687,7 @@ Approximation to the zero set (setting ``x_0 = 1``)::
 The zeros are generated as a group by a single vector::
 
     sage: S.points()
-    [[(1/2*I + 1/2)*sqrt(2), -(1/2*I + 1/2)*sqrt(2)]]
+    [[-(1/2*I + 1/2)*sqrt(2), (1/2*I + 1/2)*sqrt(2)]]
 
 
 Resolutions
@@ -1384,12 +1384,12 @@ EXAMPLES::
 
     sage: s = sandpiles.Cycle(5)
     sage: s.group_gens()
-    [{1: 1, 2: 1, 3: 1, 4: 0}]
+    [{1: 0, 2: 1, 3: 1, 4: 1}]
     sage: s.group_gens()[0].order()
     5
     sage: s = sandpiles.Complete(5)
     sage: s.group_gens(False)
-    [[2, 2, 3, 2], [2, 3, 2, 2], [3, 2, 2, 2]]
+    [[2, 3, 2, 2], [2, 2, 3, 2], [2, 2, 2, 3]]
     sage: [i.order() for i in s.group_gens()]
     [5, 5, 5]
     sage: s.invariant_factors()
@@ -2058,7 +2058,7 @@ single generator for the group of solutions.
 
     sage: S = sandpiles.Complete(4)
     sage: S.points()
-    [[1, I, -I], [I, 1, -I]]
+    [[-I, I, 1], [-I, 1, I]]
 
 ---
 
@@ -4257,7 +4257,7 @@ EXAMPLES::
     sage: D.is_linearly_equivalent([0,1,1])
     True
     sage: D.is_linearly_equivalent([0,1,1],True)
-    (1, 0, 0)
+    (0, -1, -1)
     sage: v = vector(D.is_linearly_equivalent([0,1,1],True))
     sage: vector(D.values()) - s.laplacian()*v
     (0, 1, 1)
@@ -4983,8 +4983,8 @@ Other
 
         sage: P = matrix([[2,3,-7,-3],[5,2,-5,5],[8,2,5,4],[-5,-9,6,6]])
         sage: wilmes_algorithm(P)
-        [ 1642   -13 -1627    -1]
-        [   -1  1980 -1582  -397]
+        [ 3279   -79 -1599 -1600]
+        [   -1  1539  -136 -1402]
         [    0    -1  1650 -1649]
         [    0     0 -1658  1658]
 
diff --git a/src/sage/arith/misc.py b/src/sage/arith/misc.py
index 173baa3b79..62977f095e 100644
--- a/src/sage/arith/misc.py
+++ b/src/sage/arith/misc.py
@@ -1458,13 +1458,13 @@ def divisors(n):
 
         sage: K.<a> = QuadraticField(7)
         sage: divisors(K.ideal(7))
-        [Fractional ideal (1), Fractional ideal (a), Fractional ideal (7)]
+        [Fractional ideal (1), Fractional ideal (-a), Fractional ideal (7)]
         sage: divisors(K.ideal(3))
         [Fractional ideal (1), Fractional ideal (3),
         Fractional ideal (-a + 2), Fractional ideal (-a - 2)]
         sage: divisors(K.ideal(35))
-        [Fractional ideal (1), Fractional ideal (5), Fractional ideal (a),
-        Fractional ideal (7), Fractional ideal (5*a), Fractional ideal (35)]
+        [Fractional ideal (1), Fractional ideal (5), Fractional ideal (-a),
+        Fractional ideal (7), Fractional ideal (-5*a), Fractional ideal (35)]
 
     TESTS::
 
diff --git a/src/sage/ext_data/pari/simon/ell.gp b/src/sage/ext_data/pari/simon/ell.gp
index 74f0786646..21cff9cbb3 100644
--- a/src/sage/ext_data/pari/simon/ell.gp
+++ b/src/sage/ext_data/pari/simon/ell.gp
@@ -1038,7 +1038,7 @@ if( DEBUGLEVEL_ell >= 1, print(" trivial points on E(K) = ");
   KS2gen = KS2gen[1];
   for( i = 1, #KS2gen,
     KS2gen[i] = nfbasistoalg(bnf, KS2gen[i]));
-  KS2gen = concat(Mod(lift(bnf.tufu),bnf.pol),KS2gen);
+  KS2gen = concat(Mod(lift(concat(bnf.tu[2], bnf.fu)),bnf.pol),KS2gen);
 if( DEBUGLEVEL_ell >= 2,
   print("  #K(b,2)gen          = ",#KS2gen);
   print("  K(b,2)gen = ",KS2gen));
@@ -1072,7 +1072,7 @@ if( DEBUGLEVEL_ell >= 1,
   KS2gen = KS2gen[1];
   for( i = 1, #KS2gen,
     KS2gen[i] = nfbasistoalg(bnf, KS2gen[i]));
-  KS2gen = concat(Mod(lift(bnf.tufu),bnf.pol),KS2gen);
+  KS2gen = concat(Mod(lift(concat(bnf.tu[2], bnf.fu)),bnf.pol),KS2gen);
 if( DEBUGLEVEL_ell >= 2,
   print("  #K(a^2-4b,2)gen     = ",#KS2gen);
   print("  K(a^2-4b,2)gen     = ",KS2gen));
@@ -1244,11 +1244,11 @@ if( DEBUGLEVEL_ell >= 4, print("    bbbnf.clgp = ",bbbnf.clgp));
   SL1 = idealmul(bbbnf,SL0,rnfeltup(rrrnf,bleg));
   SL = idealfactor(bbbnf,SL1)[,1]~;
   sunL = bnfsunit(bbbnf,SL);
-  fondsunL = concat(bbbnf.futu,vector(#sunL[1],i,nfbasistoalg(bbbnf,sunL[1][i])));
+  fondsunL = concat(concat(bbbnf.fu, bbbnf.tu[2]),vector(#sunL[1],i,nfbasistoalg(bbbnf,sunL[1][i])));
   normfondsunL = vector(#fondsunL, i, norm(rnfeltabstorel(rrrnf,fondsunL[i])));
   SK = idealfactor(bnf,idealnorm(bbbnf,SL1))[,1]~;
   sunK = bnfsunit(bnf,SK);
-  fondsunK = concat(bnf.futu,vector(#sunK[1],i,nfbasistoalg(bnf,sunK[1][i])));
+  fondsunK = concat(concat(bnf.fu, bnf.tu[2]),vector(#sunK[1],i,nfbasistoalg(bnf,sunK[1][i])));
   vecbleg = bnfissunit(bnf,sunK,bleg);
   matnorm = matrix(#fondsunK,#normfondsunL,i,j,0);
   for( i = 1, #normfondsunL,
@@ -1345,7 +1345,7 @@ if( DEBUGLEVEL_ell >= 4, print("on factorise bb = ",bb));
       sun = bnfsunit(bnf,idealfactor(bnf,bb)[,1]~);
       fact = lift(bnfissunit(bnf,sun,bb));
 if( DEBUGLEVEL_ell >= 4, print("fact = ",fact));
-      suni = concat(bnf.futu,vector(#sun[1],i,nfbasistoalg(bnf,sun[1][i])));
+      suni = concat(concat(bnf.fu, bnf.tu[2]),vector(#sun[1],i,nfbasistoalg(bnf,sun[1][i])));
       for( i = 1, #suni,
         if( (f = fact[i]>>1), 
           test =0;
@@ -1554,7 +1554,7 @@ if( DEBUGLEVEL_ell >= 3, print("    KS2gen = ",KS2gen[1]));
 
   LS2gen = LS2gen[1];
   LS2 = vector(#LS2gen,i,lift(nfbasistoalg(Lrnf,LS2gen[i])));
-  LS2 = concat(lift(Lrnf.futu),LS2);
+  LS2 = concat(lift(concat(Lrnf.fu, Lrnf.tu[2])),LS2);
 
   LS2 = subst(LS2,'x,ttheta);
   LS2 = LS2*Mod(1,polrel);
@@ -1992,7 +1992,7 @@ if( DEBUGLEVEL_ell >= 2, print("  Algorithm of complete 2-descent"));
   KS2gen = KS2gen[1];
   for( i = 1, #KS2gen,
     KS2gen[i] = nfbasistoalg(bnf, KS2gen[i]));
-  KS2gen = concat(Mod(lift(bnf.tufu),bnf.pol),KS2gen);
+  KS2gen = concat(Mod(lift(concat(bnf.tu[2], bnf.fu)),bnf.pol),KS2gen);
 if( DEBUGLEVEL_ell >= 2,
   print("  #K(S,2)gen = ",#KS2gen);
   print("   K(S,2)gen = ",KS2gen)
diff --git a/src/sage/ext_data/pari/simon/ellQ.gp b/src/sage/ext_data/pari/simon/ellQ.gp
index 1cfe6318f8..420af8f6a2 100644
--- a/src/sage/ext_data/pari/simon/ellQ.gp
+++ b/src/sage/ext_data/pari/simon/ellQ.gp
@@ -1162,7 +1162,7 @@ if( DEBUGLEVEL_ell >= 4, print("    kerval = ",kerval));
       LS2gen[j]^kerval[j,i]));
 
 \\ Add the units
-  LS2gen = concat(Mod(bnf[8][5],bnf.pol),LS2gen); \\ LS2gen = concat(bnf.fu,LS2gen);
+  LS2gen = concat(bnf.fu,LS2gen); \\ LS2gen = concat(bnf.fu,LS2gen);
 \\ Add also the torsion unit if its order is divisible by p.
   if( bnf[8][4][1]%p == 0, \\ if( bnf.tu[1]%p == 0,
     LS2gen = concat( [Mod(bnf[8][4][2],bnf.pol)], LS2gen)); \\ LS2gen = concat( [Mod(bnf.tu[2],bnf.pol)], LS2gen));
diff --git a/src/sage/geometry/cone.py b/src/sage/geometry/cone.py
index 79c75ad784..5b2326a8e7 100644
--- a/src/sage/geometry/cone.py
+++ b/src/sage/geometry/cone.py
@@ -3504,8 +3504,8 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
 
             sage: K = Cone([(1,0,0), (0,1,0)])
             sage: K.solid_restriction().rays()
-            N(1, 0),
-            N(0, 1)
+            N(0, 1),
+            N(1, 0)
             in 2-d lattice N
 
         The solid restriction of a single ray has the same
@@ -3624,7 +3624,7 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             sage: C2_Z2 = Cone([(1,0),(1,2)])
             sage: C2_Z2._split_ambient_lattice()
             sage: C2_Z2._sublattice
-            Sublattice <N(1, 2), N(0, -1)>
+            Sublattice <N(1, 0), N(0, 1)>
 
         Trivial cone::
 
@@ -3695,9 +3695,9 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             sage: cone.rays().basis().matrix().det()
             -4
             sage: cone.sublattice()
-            Sublattice <N(-1, -1, 1), N(1, 0, 0), N(1, 1, 0)>
+            Sublattice <N(1, 1, 1), N(0, -1, 0), N(-1, -1, 0)>
             sage: matrix( cone.sublattice().gens() ).det()
-            1
+            -1
 
         Another example::
 
@@ -3709,7 +3709,7 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             N(4, -5, 1)
             in 3-d lattice N
             sage: c.sublattice()
-            Sublattice <N(1, 2, 3), N(4, -5, 1)>
+            Sublattice <N(4, -5, 1), N(1, 2, 3)>
             sage: c.sublattice(5, -3, 4)
             N(5, -3, 4)
             sage: c.sublattice(1, 0, 0)
@@ -3805,14 +3805,14 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
 
             sage: c = Cone([(1,2,3), (4,-5,1)])
             sage: c.sublattice()
-            Sublattice <N(1, 2, 3), N(4, -5, 1)>
+            Sublattice <N(4, -5, 1), N(1, 2, 3)>
             sage: c.sublattice_complement()
-            Sublattice <N(0, -6, -5)>
+            Sublattice <N(2, -3, 0)>
             sage: m = matrix( c.sublattice().gens() + c.sublattice_complement().gens() )
             sage: m
-            [ 1  2  3]
             [ 4 -5  1]
-            [ 0 -6 -5]
+            [ 1  2  3]
+            [ 2 -3  0]
             sage: m.det()
             -1
             """
@@ -3856,7 +3856,7 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             Sublattice <>
             sage: c12 = Cone([(1,1,1), (1,-1,1)])
             sage: c12.sublattice()
-            Sublattice <N(1, -1, 1), N(0, 1, 0)>
+            Sublattice <N(1, 1, 1), N(0, -1, 0)>
             sage: c12.orthogonal_sublattice()
             Sublattice <M(1, 0, -1)>
 
@@ -3922,15 +3922,15 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             sage: sigma = Cone([(1,1,1,3),(1,-1,1,3),(-1,-1,1,3),(-1,1,1,3)])
             sage: rho   = Cone([(-1, -1, 1, 3), (-1, 1, 1, 3)])
             sage: sigma.sublattice()
-            Sublattice <N(-1, -1, 1, 3), N(1, 0, 0, 0), N(1, 1, 0, 0)>
+            Sublattice <N(1, 1, 1, 3), N(0, -1, 0, 0), N(-1, -1, 0, 0)>
             sage: rho.sublattice()
-            Sublattice <N(-1, 1, 1, 3), N(0, -1, 0, 0)>
+            Sublattice <N(-1, -1, 1, 3), N(0, 1, 0, 0)>
             sage: sigma.relative_quotient(rho)
             1-d lattice, quotient
-            of Sublattice <N(-1, -1, 1, 3), N(1, 0, 0, 0), N(1, 1, 0, 0)>
+            of Sublattice <N(1, 1, 1, 3), N(0, -1, 0, 0), N(-1, -1, 0, 0)>
             by Sublattice <N(1, 0, -1, -3), N(0, 1, 0, 0)>
             sage: sigma.relative_quotient(rho).gens()
-            (N[1, 1, 0, 0],)
+            (N[1, 0, 0, 0],)
 
         More complicated example::
 
@@ -3938,12 +3938,12 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             sage: sigma = Cone([(1, 2, 3), (1, -1, 1), (-1, 1, 1), (-1, -1, 1)])
             sage: N_sigma = sigma.sublattice()
             sage: N_sigma
-            Sublattice <N(-1, 1, 1), N(1, 2, 3), N(0, 1, 1)>
+            Sublattice <N(1, 2, 3), N(1, -1, 1), N(-1, -1, -2)>
             sage: N_rho = rho.sublattice()
             sage: N_rho
             Sublattice <N(1, -1, 1), N(1, 2, 3)>
             sage: sigma.relative_quotient(rho).gens()
-            (N[0, 1, 1],)
+            (N[-1, -1, -2],)
             sage: N = rho.lattice()
             sage: N_sigma == N.span(N_rho.gens() + tuple(q.lift()
             ....:            for q in sigma.relative_quotient(rho).gens()))
@@ -3958,12 +3958,12 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             Sublattice <N(1, -1, 1), N(1, 2, 3)>
             sage: sigma1.relative_quotient(rho)
             1-d lattice, quotient
-            of Sublattice <N(-1, 1, 1), N(1, 2, 3), N(0, 1, 1)>
+            of Sublattice <N(1, 2, 3), N(1, -1, 1), N(-1, -1, -2)>
             by Sublattice <N(1, 2, 3), N(0, 3, 2)>
             sage: sigma1.relative_quotient(rho).gens()
-            (N[0, 1, 1],)
+            (N[-1, -1, -2],)
             sage: sigma2.relative_quotient(rho).gens()
-            (N[-1, 0, -2],)
+            (N[0, 2, 1],)
         """
         try:
             cached_values = self._relative_quotient
@@ -4263,9 +4263,9 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             sage: Cone([[1,0],[3,4]]).dual().Hilbert_basis()
             M(0,  1),
             M(4, -3),
-            M(3, -2),
+            M(1,  0),
             M(2, -1),
-            M(1,  0)
+            M(3, -2)
             in 2-d lattice M
             sage: cone = Cone([[1,2,3,4],[0,1,0,7],[3,1,0,2],[0,0,1,0]]).dual()
             sage: cone.Hilbert_basis()           # long time
@@ -4275,16 +4275,16 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             M(15, -63, 25,  9),
             M( 2,  -3,  0,  1),
             M( 1,  -4,  1,  1),
-            M(-1,   3,  0,  0),
             M( 4,  -4,  0,  1),
+            M(-1,   3,  0,  0),
             M( 1,  -5,  2,  1),
             M( 3,  -5,  1,  1),
             M( 6,  -5,  0,  1),
             M( 3, -13,  5,  2),
             M( 2,  -6,  2,  1),
             M( 5,  -6,  1,  1),
-            M( 0,   1,  0,  0),
             M( 8,  -6,  0,  1),
+            M( 0,   1,  0,  0),
             M(-2,   8,  0, -1),
             M(10, -42, 17,  6),
             M( 7, -28, 11,  4),
@@ -4295,9 +4295,9 @@ class ConvexRationalPolyhedralCone(IntegralRayCollection, Container):
             M( 4,  -7,  2,  1),
             M( 7,  -7,  1,  1),
             M( 0,   0,  1,  0),
-            M(-3,  14,  0, -2),
+            M( 1,   0,  0,  0),
             M(-1,   7,  0, -1),
-            M( 1,   0,  0,  0)
+            M(-3,  14,  0, -2)
             in 4-d lattice M
 
         Not a strictly convex cone::
diff --git a/src/sage/geometry/fan.py b/src/sage/geometry/fan.py
index c5c3eb646e..2380086903 100644
--- a/src/sage/geometry/fan.py
+++ b/src/sage/geometry/fan.py
@@ -3008,8 +3008,8 @@ class RationalPolyhedralFan(IntegralRayCollection, Callable, Container):
 
             sage: f = Fan([Cone([(1,0,1,0), (0,1,1,0)])])
             sage: f.virtual_rays()
-            N(0, 0, 0, 1),
-            N(0, 0, 1, 0)
+            N(1, 0, 0, 0),
+            N(0, 0, 0, 1)
             in 4-d lattice N
 
             sage: f.rays()
@@ -3018,14 +3018,14 @@ class RationalPolyhedralFan(IntegralRayCollection, Callable, Container):
             in 4-d lattice N
 
             sage: f.virtual_rays([0])
-            N(0, 0, 0, 1)
+            N(1, 0, 0, 0)
             in 4-d lattice N
 
         You can also give virtual ray indices directly, without
         packing them into a list::
 
             sage: f.virtual_rays(0)
-            N(0, 0, 0, 1)
+            N(1, 0, 0, 0)
             in 4-d lattice N
 
         Make sure that :trac:`16344` is fixed and one can compute
diff --git a/src/sage/geometry/fan_isomorphism.py b/src/sage/geometry/fan_isomorphism.py
index 04732ab0c2..18a6c9b199 100644
--- a/src/sage/geometry/fan_isomorphism.py
+++ b/src/sage/geometry/fan_isomorphism.py
@@ -96,9 +96,9 @@ def fan_isomorphism_generator(fan1, fan2):
         ....:             Cone([m2*vector([-1,-14]), m2*vector([-100, -5])])])
         sage: sorted(fan_isomorphism_generator(fan1, fan2))
         [
-        [18  1 -5]
-        [ 4  0 -1]
-        [ 5  0 -1]
+        [-12  1 -5]
+        [ -4  0 -1]
+        [ -5  0 -1]
         ]
 
         sage: m0 = identity_matrix(ZZ, 2)
@@ -125,15 +125,15 @@ def fan_isomorphism_generator(fan1, fan2):
         ]
         sage: sorted(fan_isomorphism_generator(fan1, fan2))
         [
-        [ 6 -3  7]  [18  1 -5]
-        [ 1 -1  2]  [ 4  0 -1]
-        [ 2 -1  2], [ 5  0 -1]
+        [-24  -3   7]  [-12   1  -5]
+        [ -7  -1   2]  [ -4   0  -1]
+        [ -8  -1   2], [ -5   0  -1]
         ]
         sage: sorted(fan_isomorphism_generator(fan2, fan1))
         [
-        [ 0 -1  1]  [ 0 -1  1]
-        [ 1 -7  2]  [ 2 -2 -5]
-        [ 0 -5  4], [ 1  0 -3]
+        [  0   1  -1]  [ 0  1 -1]
+        [  1 -13   8]  [ 2 -8  1]
+        [  0  -5   4], [ 1  0 -3]
         ]
     """
     if not fan_isomorphic_necessary_conditions(fan1, fan2):
diff --git a/src/sage/geometry/integral_points.pyx b/src/sage/geometry/integral_points.pyx
index 765b0a5bb5..37e1d23339 100644
--- a/src/sage/geometry/integral_points.pyx
+++ b/src/sage/geometry/integral_points.pyx
@@ -108,13 +108,13 @@ cpdef tuple parallelotope_points(spanning_points, lattice):
         sage: from sage.geometry.integral_points import parallelotope_points
         sage: rays = list(map(vector, [(2,0), (0,2)]))
         sage: parallelotope_points(rays, ZZ^2)
-        ((0, 0), (1, 0), (0, 1), (1, 1))
+        ((0, 0), (0, 1), (1, 0), (1, 1))
 
     The rays can also be toric lattice points::
 
         sage: rays = list(map(ToricLattice(2), [(2,0), (0,2)]))
         sage: parallelotope_points(rays, ToricLattice(2))
-        (N(0, 0), N(1, 0), N(0, 1), N(1, 1))
+        (N(0, 0), N(0, 1), N(1, 0), N(1, 1))
 
     A non-smooth cone::
 
diff --git a/src/sage/geometry/polyhedron/ppl_lattice_polytope.py b/src/sage/geometry/polyhedron/ppl_lattice_polytope.py
index 4236419276..5bf4d59b14 100644
--- a/src/sage/geometry/polyhedron/ppl_lattice_polytope.py
+++ b/src/sage/geometry/polyhedron/ppl_lattice_polytope.py
@@ -863,7 +863,7 @@ class LatticePolytope_PPL_class(C_Polyhedron):
             sage: proj = poly.base_projection(fiber)
             sage: proj_matrix = poly.base_projection_matrix(fiber)
             sage: [ proj(p) for p in poly.integral_points() ]
-            [(-1, -1), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (1, 0), (0, 1)]
+            [(-1, -1), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (1, 0)]
             sage: [ proj_matrix*p for p in poly.integral_points() ]
             [(-1, -1), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (1, 0)]
         """
diff --git a/src/sage/geometry/toric_lattice.py b/src/sage/geometry/toric_lattice.py
index 4444d662be..4d8ef3fba6 100644
--- a/src/sage/geometry/toric_lattice.py
+++ b/src/sage/geometry/toric_lattice.py
@@ -425,7 +425,7 @@ class ToricLattice_generic(FreeModule_generic_pid):
             sage: N3 = ToricLattice(3, 'N3')
             sage: Q = N3 / N3.span([ N3(1,2,3) ])
             sage: Q.an_element()
-            N3[0, 0, 1]
+            N3[1, 0, 0]
             sage: N2 = ToricLattice(2, 'N2')
             sage: N2( Q.an_element() )
             N2(1, 0)
@@ -1297,9 +1297,9 @@ class ToricLattice_quotient_element(FGP_Element):
         sage: e == e2
         True
         sage: e.vector()
-        (4)
+        (-4)
         sage: e2.vector()
-        (4)
+        (-4)
     """
 
     def _latex_(self):
@@ -1407,7 +1407,7 @@ class ToricLattice_quotient(FGP_Module_class):
         sage: Q
         1-d lattice, quotient of 3-d lattice N by Sublattice <N(1, 0, 1), N(0, 1, -1)>
         sage: Q.gens()
-        (N[0, 0, 1],)
+        (N[1, 0, 0],)
 
     Here, ``sublattice`` happens to be of codimension one in ``N``. If
     you want to prescribe the sign of the quotient generator, you can
@@ -1416,15 +1416,15 @@ class ToricLattice_quotient(FGP_Module_class):
         sage: Q = N.quotient(sublattice, positive_point=N(0,0,-1)); Q
         1-d lattice, quotient of 3-d lattice N by Sublattice <N(1, 0, 1), N(0, 1, -1)>
         sage: Q.gens()
-        (N[0, 0, -1],)
+        (N[1, 0, 0],)
 
     or::
 
         sage: M = N.dual()
-        sage: Q = N.quotient(sublattice, positive_dual_point=M(0,0,-1)); Q
+        sage: Q = N.quotient(sublattice, positive_dual_point=M(1,0,0)); Q
         1-d lattice, quotient of 3-d lattice N by Sublattice <N(1, 0, 1), N(0, 1, -1)>
         sage: Q.gens()
-        (N[0, 0, -1],)
+        (N[1, 0, 0],)
 
     TESTS::
 
diff --git a/src/sage/groups/abelian_gps/abelian_group.py b/src/sage/groups/abelian_gps/abelian_group.py
index e6d8e16903..a493506524 100644
--- a/src/sage/groups/abelian_gps/abelian_group.py
+++ b/src/sage/groups/abelian_gps/abelian_group.py
@@ -1523,7 +1523,7 @@ class AbelianGroup_class(UniqueRepresentation, AbelianGroupBase):
             generated by {f0, f0*f1^2}
             sage: AbelianGroup([4,4]).subgroup_reduced( [ [1,0], [1,2] ])
             Multiplicative Abelian subgroup isomorphic to C2 x C4
-            generated by {f1^2, f0}
+            generated by {f0^2*f1^2, f0^3}
         """
         from sage.matrix.constructor import matrix
         d = self.ngens()
diff --git a/src/sage/groups/additive_abelian/additive_abelian_group.py b/src/sage/groups/additive_abelian/additive_abelian_group.py
index 3dcedeb7e3..2c76b75e0c 100644
--- a/src/sage/groups/additive_abelian/additive_abelian_group.py
+++ b/src/sage/groups/additive_abelian/additive_abelian_group.py
@@ -43,7 +43,7 @@ def AdditiveAbelianGroup(invs, remember_generators = True):
         sage: H = AdditiveAbelianGroup([0, 2, 3], remember_generators = False); H
         Additive abelian group isomorphic to Z/6 + Z
         sage: H.gens()
-        ((0, 1, 2), (1, 0, 0))
+        ((0, 1, 1), (1, 0, 0))
 
     There are several ways to create elements of an additive abelian group.
     Realize that there are two sets of generators:  the "obvious" ones composed
diff --git a/src/sage/groups/fqf_orthogonal.py b/src/sage/groups/fqf_orthogonal.py
index 3c5190589b..ae9fc2fae2 100644
--- a/src/sage/groups/fqf_orthogonal.py
+++ b/src/sage/groups/fqf_orthogonal.py
@@ -133,16 +133,16 @@ class FqfOrthogonalGroup(AbelianGroupAutomorphismGroup_subgroup):
         sage: T
         Finite quadratic module over Integer Ring with invariants (3, 3, 3)
         Gram matrix of the quadratic form with values in Q/2Z:
-        [4/3   0   0]
+        [2/3   0   0]
         [  0 2/3   0]
-        [  0   0 2/3]
+        [  0   0 4/3]
         sage: T.orthogonal_group()
         Group of isometries of
         Finite quadratic module over Integer Ring with invariants (3, 3, 3)
         Gram matrix of the quadratic form with values in Q/2Z:
-        [4/3   0   0]
+        [2/3   0   0]
         [  0 2/3   0]
-        [  0   0 2/3]
+        [  0   0 4/3]
         generated by 2 elements
         sage: q = matrix.diagonal(QQ, [3/2, 1/4, 1/4])
         sage: T = TorsionQuadraticForm(q)
@@ -158,7 +158,7 @@ class FqfOrthogonalGroup(AbelianGroupAutomorphismGroup_subgroup):
         sage: G = T.orthogonal_group()
         sage: g = G(matrix(ZZ, 2, [8, 0, 0, 1]))
         sage: Q.1 * g
-        (0, 2)
+        (0, 1)
     """
     Element = FqfIsometry
 
@@ -225,8 +225,8 @@ class FqfOrthogonalGroup(AbelianGroupAutomorphismGroup_subgroup):
             sage: f = OL(f)
             sage: fbar = Oq(f)
             sage: fbar
-            [4 3]
-            [3 1]
+            [1 3]
+            [3 4]
 
         Note that the following does not work since it may lead to ambiguities, see :trac:`30669`::
 
@@ -307,12 +307,12 @@ class FqfOrthogonalGroup(AbelianGroupAutomorphismGroup_subgroup):
             Right action by Group of isometries of
             Finite quadratic module over Integer Ring with invariants (3, 3)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [4/3   0]
-            [  0 2/3]
+            [2/3   0]
+            [  0 4/3]
             generated by 2 elements on Finite quadratic module over Integer Ring with invariants (3, 3)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [4/3   0]
-            [  0 2/3]
+            [2/3   0]
+            [  0 4/3]
         """
         import operator
         if op == operator.mul and not self_on_left:
@@ -450,19 +450,19 @@ class ActionOnFqf(Action):
             Right action by Group of isometries of
             Finite quadratic module over Integer Ring with invariants (3, 3)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [4/3   0]
-            [  0 2/3]
+            [2/3   0]
+            [  0 4/3]
             generated by 2 elements on Finite quadratic module over Integer Ring with invariants (3, 3)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [4/3   0]
-            [  0 2/3]
+            [2/3   0]
+            [  0 4/3]
             sage: x = q.an_element()
             sage: g = G.an_element()
             sage: A(x, g).parent()
             Finite quadratic module over Integer Ring with invariants (3, 3)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [4/3   0]
-            [  0 2/3]
+            [2/3   0]
+            [  0 4/3]
             sage: q = TorsionQuadraticForm(matrix.diagonal([2/3, 2/3, 6/8, 1/4]))
             sage: G = q.orthogonal_group()
             sage: q2 = q.primary_part(2)
diff --git a/src/sage/homology/chain_complex.py b/src/sage/homology/chain_complex.py
index 49aaff1a85..47d14b4b9c 100644
--- a/src/sage/homology/chain_complex.py
+++ b/src/sage/homology/chain_complex.py
@@ -1270,7 +1270,7 @@ class ChainComplex_class(Parent):
             sage: C_k = ChainComplex({0:d0, 1:d1, 2:d2}, degree=-1)
             sage: C_k.homology(generators=true, algorithm='no_chomp')
             {0: [(Z, Chain(0:(1)))],
-             1: [(C2, Chain(1:(1, 0, 0))), (Z, Chain(1:(0, 0, 1)))],
+             1: [(C2, Chain(1:(0, 1, -1))), (Z, Chain(1:(0, 1, 0)))],
              2: []}
 
         From a torus using a field::
diff --git a/src/sage/homology/simplicial_complex.py b/src/sage/homology/simplicial_complex.py
index 8db479fd54..6c71bce482 100644
--- a/src/sage/homology/simplicial_complex.py
+++ b/src/sage/homology/simplicial_complex.py
@@ -2305,7 +2305,7 @@ class SimplicialComplex(Parent, GenericCellComplex):
 
             sage: simplicial_complexes.Torus().homology(generators=True, algorithm='no_chomp')
             {0: [],
-             1: [(Z, (1, 2) - (1, 6) + (2, 6)), (Z, (3, 4) - (3, 6) + (4, 6))],
+             1: [(Z, (2, 4) - (2, 6) + (4, 6)), (Z, (1, 4) - (1, 6) + (4, 6))],
              2: [(Z,
                (0, 1, 2) - (0, 1, 5) + (0, 2, 6) - (0, 3, 4) + (0, 3, 5) - (0, 4, 6) - (1, 2, 4) + (1, 3, 4) - (1, 3, 6) + (1, 5, 6) - (2, 3, 5) + (2, 3, 6) + (2, 4, 5) - (4, 5, 6))]}
         """
diff --git a/src/sage/lfunctions/pari.py b/src/sage/lfunctions/pari.py
index f810157b3e..f621b57c67 100644
--- a/src/sage/lfunctions/pari.py
+++ b/src/sage/lfunctions/pari.py
@@ -421,7 +421,7 @@ class LFunction(SageObject):
         sage: L.derivative(1,E.rank())
         1.51863300057685
         sage: L.taylor_series(1,4)
-        -3...e-19 + (...e-19)*z + 0.759316500288427*z^2 - 0.430302337583362*z^3 + O(z^4)
+        ...e-19 + (...e-19)*z + 0.759316500288427*z^2 - 0.430302337583362*z^3 + O(z^4)
 
     .. RUBRIC:: Number field
 
diff --git a/src/sage/libs/pari/__init__.py b/src/sage/libs/pari/__init__.py
index 77eda66097..e9112b2e3e 100644
--- a/src/sage/libs/pari/__init__.py
+++ b/src/sage/libs/pari/__init__.py
@@ -161,12 +161,12 @@ exact object. Therefore, you should set the precision for each method
 call individually::
 
     sage: e = pari([0,0,0,-82,0]).ellinit()
-    sage: eta1 = e.elleta(precision=100)[0]
+    sage: eta1 = e.elleta(precision=50)[0]
     sage: eta1.sage()
     3.6054636014326520859158205642077267748
-    sage: eta1 = e.elleta(precision=180)[0]
+    sage: eta1 = e.elleta(precision=150)[0]
     sage: eta1.sage()
-    3.60546360143265208591582056420772677481026899659802474544
+    3.605463601432652085915820564207726774810268996598024745444380641429820491740
 
 """
 
diff --git a/src/sage/libs/pari/tests.py b/src/sage/libs/pari/tests.py
index dd7f8e9bf8..2aa382269a 100644
--- a/src/sage/libs/pari/tests.py
+++ b/src/sage/libs/pari/tests.py
@@ -135,7 +135,7 @@ Some more exotic examples::
 
     sage: K.<a> = NumberField(polygen(QQ)^3 - 2)
     sage: pari(K)
-    [y^3 - 2, [1, 1], -108, 1, [[1, 1.25992104989487, 1.58740105196820; 1, -0.629960524947437 + 1.09112363597172*I, -0.793700525984100 - 1.37472963699860*I], [1, 1.25992104989487, 1.58740105196820; 1, 0.461163111024285, -2.16843016298270; 1, -1.72108416091916, 0.581029111014503], [1, 1, 2; 1, 0, -2; 1, -2, 1], [3, 0, 0; 0, 0, 6; 0, 6, 0], [6, 0, 0; 0, 6, 0; 0, 0, 3], [2, 0, 0; 0, 0, 1; 0, 1, 0], [2, [0, 0, 2; 1, 0, 0; 0, 1, 0]], []], [1.25992104989487, -0.629960524947437 + 1.09112363597172*I], [1, y, y^2], [1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 0, 0, 0, 0, 2, 0, 2, 0; 0, 1, 0, 1, 0, 0, 0, 0, 2; 0, 0, 1, 0, 1, 0, 1, 0, 0]]
+    [y^3 - 2, [1, 1], -108, 1, [[1, 1.25992104989487, 1.58740105196820; 1, -0.629960524947437 + 1.09112363597172*I, -0.793700525984100 - 1.37472963699860*I], [1, 1.25992104989487, 1.58740105196820; 1, 0.461163111024285, -2.16843016298270; 1, -1.72108416091916, 0.581029111014503], [16, 20, 25; 16, 7, -35; 16, -28, 9], [3, 0, 0; 0, 0, 6; 0, 6, 0], [6, 0, 0; 0, 6, 0; 0, 0, 3], [2, 0, 0; 0, 0, 1; 0, 1, 0], [2, [0, 0, 2; 1, 0, 0; 0, 1, 0]], [2, 3]], [1.25992104989487, -0.629960524947437 + 1.09112363597172*I], [1, y, y^2], [1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 0, 0, 0, 0, 2, 0, 2, 0; 0, 1, 0, 1, 0, 0, 0, 0, 2; 0, 0, 1, 0, 1, 0, 1, 0, 0]]
 
     sage: E = EllipticCurve('37a1')
     sage: pari(E)
@@ -375,13 +375,13 @@ Constructors::
     sage: pari('["bc","ab","bc"]').Set()
     ["ab", "bc"]
 
-    sage: pari([65,66,123]).Strchr()
+    sage: pari([65,66,123]).strchr()
     "AB{"
     sage: pari('"Sage"').Vecsmall()
     Vecsmall([83, 97, 103, 101])
-    sage: _.Strchr()
+    sage: _.strchr()
     "Sage"
-    sage: pari([83, 97, 103, 101]).Strchr()
+    sage: pari([83, 97, 103, 101]).strchr()
     "Sage"
 
 Basic functions::
@@ -448,7 +448,7 @@ Basic functions::
     sage: pari('x').component(0)
     Traceback (most recent call last):
     ...
-    PariError: non-existent component: index < 1
+    PariError: nonexistent component: index < 1
 
     sage: pari('x+1').conj()
     x + 1
@@ -767,7 +767,7 @@ Transcendental functions::
     sage: pari(2).besseli(3+i)
     1.12539407613913 + 2.08313822670661*I
     sage: C.<i> = ComplexField()
-    sage: pari(2+i).besseln(3)
+    sage: pari(2+i).bessely(3)
     -0.280775566958244 - 0.486708533223726*I
 
     sage: pari(1.5).cos()
@@ -822,7 +822,7 @@ Transcendental functions::
     sage: pari(-1).gamma()
     Traceback (most recent call last):
     ...
-    PariError: domain error in gamma: argument = non-positive integer
+    PariError: domain error in gamma: argument = nonpositive integer
 
     sage: pari(2).gammah()
     1.32934038817914
@@ -1633,7 +1633,7 @@ General number fields::
 
     sage: x = QQ['x'].0; nf = pari(x^2 + 2).nfinit()
     sage: nf.nfgaloisconj()
-    [x, -x]~
+    [-x, x]~
     sage: nf = pari(x^3 + 2).nfinit()
     sage: nf.nfgaloisconj()
     [x]~
@@ -1676,7 +1676,7 @@ General number fields::
     [[1, [7605, 4]~, [5610, 5]~, [7913, -6]~; 0, 1, 0, -1; 0, 0, 1, 0; 0, 0, 0, 1], [[19320, 13720; 0, 56], [2, 1; 0, 1], 1, 1]]
 
     sage: pari('x^3 - 17').nfinit()
-    [x^3 - 17, [1, 1], -867, 3, [[1, 1.68006914259990, 2.57128159065824; 1, -0.340034571299952 - 2.65083754153991*I, -1.28564079532912 + 2.22679517779329*I], [1, 1.68006914259990, 2.57128159065824; 1, -2.99087211283986, 0.941154382464174; 1, 2.31080297023995, -3.51243597312241], [1, 2, 3; 1, -3, 1; 1, 2, -4], [3, 1, 0; 1, -11, 17; 0, 17, 0], [51, 0, 16; 0, 17, 3; 0, 0, 1], [17, 0, -1; 0, 0, 3; -1, 3, 2], [51, [-17, 6, -1; 0, -18, 3; 1, 0, -16]], [3, 17]], [2.57128159065824, -1.28564079532912 + 2.22679517779329*I], [3, x^2 - x + 1, 3*x], [1, 0, -1; 0, 0, 3; 0, 1, 1], [1, 0, 0, 0, -4, 6, 0, 6, -1; 0, 1, 0, 1, 1, -1, 0, -1, 3; 0, 0, 1, 0, 2, 0, 1, 0, 1]]
+    [x^3 - 17, [1, 1], -867, 3, [[1, 1.68006914259990, 2.57128159065824; 1, -0.340034571299952 - 2.65083754153991*I, -1.28564079532912 + 2.22679517779329*I], [1, 1.68006914259990, 2.57128159065824; 1, -2.99087211283986, 0.941154382464174; 1, 2.31080297023995, -3.51243597312241], [16, 27, 41; 16, -48, 15; 16, 37, -56], [3, 1, 0; 1, -11, 17; 0, 17, 0], [51, 0, 16; 0, 17, 3; 0, 0, 1], [17, 0, -1; 0, 0, 3; -1, 3, 2], [51, [-17, 6, -1; 0, -18, 3; 1, 0, -16]], [3, 17]], [2.57128159065824, -1.28564079532912 + 2.22679517779329*I], [3, x^2 - x + 1, 3*x], [1, 0, -1; 0, 0, 3; 0, 1, 1], [1, 0, 0, 0, -4, 6, 0, 6, -1; 0, 1, 0, 1, 1, -1, 0, -1, 3; 0, 0, 1, 0, 2, 0, 1, 0, 1]]
     sage: pari('x^2 + 10^100 + 1').nfinit()
     [...]
     sage: pari('1.0').nfinit()
@@ -1737,7 +1737,7 @@ General number fields::
     sage: pari(-23).quadhilbert()
     x^3 - x^2 + 1
     sage: pari(145).quadhilbert()
-    x^4 - 6*x^2 - 5*x - 1
+    x^4 - x^3 - 5*x^2 - x + 1
     sage: pari(-12).quadhilbert()   # Not fundamental
     Traceback (most recent call last):
     ...
@@ -1760,12 +1760,12 @@ These are some doctests that used to be part of Sage and were removed from the c
 library::
 
     sage: e = pari([0,0,0,-82,0]).ellinit()
-    sage: eta1 = e.elleta(precision=100)[0]
+    sage: eta1 = e.elleta(precision=50)[0]
     sage: eta1.sage()
     3.6054636014326520859158205642077267748
-    sage: eta1 = e.elleta(precision=180)[0]
+    sage: eta1 = e.elleta(precision=150)[0]
     sage: eta1.sage()
-    3.60546360143265208591582056420772677481026899659802474544
+    3.605463601432652085915820564207726774810268996598024745444380641429820491740
 
     sage: from cypari2 import Pari
     sage: pari = Pari()
diff --git a/src/sage/matrix/matrix_integer_dense.pyx b/src/sage/matrix/matrix_integer_dense.pyx
index 5c2d94bab2..2fdcf65ac6 100644
--- a/src/sage/matrix/matrix_integer_dense.pyx
+++ b/src/sage/matrix/matrix_integer_dense.pyx
@@ -2400,13 +2400,13 @@ cdef class Matrix_integer_dense(Matrix_dense):
             [0 3 0]
             [0 0 0]
             sage: U
-            [ 0  1  0]
+            [ 0  2 -1]
             [ 0 -1  1]
-            [-1  2 -1]
+            [ 1 -2  1]
             sage: V
-            [-1  4  1]
-            [ 1 -3 -2]
             [ 0  0  1]
+            [-1  2 -2]
+            [ 1 -1  1]
             sage: U*A*V
             [1 0 0]
             [0 3 0]
@@ -2421,12 +2421,12 @@ cdef class Matrix_integer_dense(Matrix_dense):
             [0 2]
             [0 0]
             sage: U
-            [ 0  1  0]
+            [ 0  2 -1]
             [ 0 -1  1]
-            [-1  2 -1]
+            [ 1 -2  1]
             sage: V
-            [-1  3]
-            [ 1 -2]
+            [-1  1]
+            [ 1  0]
             sage: U * A * V
             [1 0]
             [0 2]
@@ -2445,7 +2445,8 @@ cdef class Matrix_integer_dense(Matrix_dense):
 
            :meth:`elementary_divisors`
         """
-        v = self.__pari__().matsnf(1).sage()
+        X = self.matrix_space()([self[i,j] for i in xrange(self._nrows-1,-1,-1) for j in xrange(self._ncols-1,-1,-1)])
+        v = X.__pari__().matsnf(1).sage()
         # need to reverse order of rows of U, columns of V, and both of D.
         D = self.matrix_space()([v[2][i,j] for i in xrange(self._nrows-1,-1,-1) for j in xrange(self._ncols-1,-1,-1)])
 
@@ -2461,13 +2462,13 @@ cdef class Matrix_integer_dense(Matrix_dense):
             # silly special cases for matrices with 0 columns (PARI has a unique empty matrix)
             U = self.matrix_space(ncols = self._nrows)(1)
         else:
-            U = self.matrix_space(ncols = self._nrows)([v[0][i,j] for i in xrange(self._nrows-1,-1,-1) for j in xrange(self._nrows)])
+            U = self.matrix_space(ncols = self._nrows)([v[0][i,j] for i in xrange(self._nrows-1,-1,-1) for j in xrange(self._nrows-1,-1,-1)])
 
         if self._nrows == 0:
             # silly special cases for matrices with 0 rows (PARI has a unique empty matrix)
             V = self.matrix_space(nrows = self._ncols)(1)
         else:
-            V = self.matrix_space(nrows = self._ncols)([v[1][i,j] for i in xrange(self._ncols) for j in xrange(self._ncols-1,-1,-1)])
+            V = self.matrix_space(nrows = self._ncols)([v[1][i,j] for i in xrange(self._ncols-1,-1,-1) for j in xrange(self._ncols-1,-1,-1)])
 
         return D, U, V
 
diff --git a/src/sage/matrix/matrix_integer_sparse.pyx b/src/sage/matrix/matrix_integer_sparse.pyx
index c53c92602e..8223fa8ab0 100644
--- a/src/sage/matrix/matrix_integer_sparse.pyx
+++ b/src/sage/matrix/matrix_integer_sparse.pyx
@@ -611,13 +611,13 @@ cdef class Matrix_integer_sparse(Matrix_sparse):
             [0 3 0]
             [0 0 0]
             sage: U
-            [ 0  1  0]
+            [ 0  2 -1]
             [ 0 -1  1]
-            [-1  2 -1]
+            [ 1 -2  1]
             sage: V
-            [-1  4  1]
-            [ 1 -3 -2]
             [ 0  0  1]
+            [-1  2 -2]
+            [ 1 -1  1]
             sage: U*A*V
             [1 0 0]
             [0 3 0]
@@ -632,12 +632,12 @@ cdef class Matrix_integer_sparse(Matrix_sparse):
             [0 2]
             [0 0]
             sage: U
-            [ 0  1  0]
+            [ 0  2 -1]
             [ 0 -1  1]
-            [-1  2 -1]
+            [ 1 -2  1]
             sage: V
-            [-1  3]
-            [ 1 -2]
+            [-1  1]
+            [ 1  0]
             sage: U * A * V
             [1 0]
             [0 2]
diff --git a/src/sage/modular/etaproducts.py b/src/sage/modular/etaproducts.py
index b656a0f7de..4a90b2cecf 100644
--- a/src/sage/modular/etaproducts.py
+++ b/src/sage/modular/etaproducts.py
@@ -146,7 +146,7 @@ class EtaGroupElement(Element):
 
             sage: eta1, eta2 = EtaGroup(4).basis() # indirect doctest
             sage: eta1 * eta2
-            Eta product of level 4 : (eta_1)^8 (eta_4)^-8
+            Eta product of level 4 : (eta_1)^24 (eta_2)^-48 (eta_4)^24
         """
         newdict = {d: self._rdict.get(d, 0) + other._rdict.get(d, 0)
                    for d in union(self._rdict, other._rdict)}
@@ -161,7 +161,7 @@ class EtaGroupElement(Element):
 
             sage: eta1, eta2 = EtaGroup(4).basis()
             sage: eta1 / eta2 # indirect doctest
-            Eta product of level 4 : (eta_1)^-24 (eta_2)^48 (eta_4)^-24
+            Eta product of level 4 : (eta_1)^-8 (eta_4)^8
             sage: (eta1 / eta2) * eta2 == eta1
             True
         """
@@ -509,16 +509,16 @@ class EtaGroup_class(UniqueRepresentation, Parent):
             sage: EtaGroup(5).basis()
             [Eta product of level 5 : (eta_1)^6 (eta_5)^-6]
             sage: EtaGroup(12).basis()
-            [Eta product of level 12 : (eta_1)^2 (eta_2)^1 (eta_3)^2 (eta_4)^-1 (eta_6)^-7 (eta_12)^3,
+            [Eta product of level 12 : (eta_1)^-3 (eta_2)^2 (eta_3)^1 (eta_4)^-1 (eta_6)^-2 (eta_12)^3,
              Eta product of level 12 : (eta_1)^-4 (eta_2)^2 (eta_3)^4 (eta_6)^-2,
+             Eta product of level 12 : (eta_1)^6 (eta_2)^-9 (eta_3)^-2 (eta_4)^3 (eta_6)^3 (eta_12)^-1,
              Eta product of level 12 : (eta_1)^-1 (eta_2)^3 (eta_3)^3 (eta_4)^-2 (eta_6)^-9 (eta_12)^6,
-             Eta product of level 12 : (eta_1)^1 (eta_2)^-1 (eta_3)^-3 (eta_4)^-2 (eta_6)^7 (eta_12)^-2,
-             Eta product of level 12 : (eta_1)^-6 (eta_2)^9 (eta_3)^2 (eta_4)^-3 (eta_6)^-3 (eta_12)^1]
+             Eta product of level 12 : (eta_1)^3 (eta_3)^-1 (eta_4)^-3 (eta_12)^1]
             sage: EtaGroup(12).basis(reduce=False) # much bigger coefficients
-            [Eta product of level 12 : (eta_2)^24 (eta_12)^-24,
-             Eta product of level 12 : (eta_1)^-336 (eta_2)^576 (eta_3)^696 (eta_4)^-216 (eta_6)^-576 (eta_12)^-144,
-             Eta product of level 12 : (eta_1)^-8 (eta_2)^-2 (eta_6)^2 (eta_12)^8,
-             Eta product of level 12 : (eta_1)^1 (eta_2)^9 (eta_3)^13 (eta_4)^-4 (eta_6)^-15 (eta_12)^-4,
+            [Eta product of level 12 : (eta_1)^384 (eta_2)^-576 (eta_3)^-696 (eta_4)^216 (eta_6)^576 (eta_12)^96,
+             Eta product of level 12 : (eta_2)^24 (eta_12)^-24,
+             Eta product of level 12 : (eta_1)^-40 (eta_2)^116 (eta_3)^96 (eta_4)^-30 (eta_6)^-80 (eta_12)^-62,
+             Eta product of level 12 : (eta_1)^-4 (eta_2)^-33 (eta_3)^-4 (eta_4)^1 (eta_6)^3 (eta_12)^37,
              Eta product of level 12 : (eta_1)^15 (eta_2)^-24 (eta_3)^-29 (eta_4)^9 (eta_6)^24 (eta_12)^5]
 
         ALGORITHM: An eta product of level `N` is uniquely
@@ -1030,7 +1030,7 @@ def _eta_relations_helper(eta1, eta2, degree, qexp_terms, labels, verbose):
         sage: from sage.modular.etaproducts import _eta_relations_helper
         sage: r,s = EtaGroup(4).basis()
         sage: _eta_relations_helper(r,s,4,100,['a','b'],False)
-        [a*b - a + 16]
+        [a + 1/16*b - 1/16]
         sage: _eta_relations_helper(EtaProduct(26, {2:2,13:2,26:-2,1:-2}),EtaProduct(26, {2:4,13:2,26:-4,1:-2}),3,12,['a','b'],False) # not enough terms, will return rubbish
         [1]
     """
diff --git a/src/sage/modular/local_comp/liftings.py b/src/sage/modular/local_comp/liftings.py
index 91bfd2448d..f629bc659b 100644
--- a/src/sage/modular/local_comp/liftings.py
+++ b/src/sage/modular/local_comp/liftings.py
@@ -222,9 +222,9 @@ def lift_for_SL(A, N=None):
     TESTS::
 
         sage: lift_for_SL(matrix(3,3,[1,2,0,3,4,0,0,0,1]),3)
-        [10 14  3]
-        [ 9 10  3]
-        [ 3  3  1]
+        [-2 -1  0]
+        [ 0  1 -3]
+        [ 3  0  4]
 
         sage: A = matrix(Zmod(7), 2, [1,0,0,1])
         sage: L = lift_for_SL(A)
diff --git a/src/sage/modular/local_comp/smoothchar.py b/src/sage/modular/local_comp/smoothchar.py
index 8bb3d46a00..3bce61f4eb 100644
--- a/src/sage/modular/local_comp/smoothchar.py
+++ b/src/sage/modular/local_comp/smoothchar.py
@@ -1624,8 +1624,8 @@ class SmoothCharacterGroupRamifiedQuadratic(SmoothCharacterGroupGeneric):
             sage: G = SmoothCharacterGroupRamifiedQuadratic(3, 1, QQ)
             sage: s = G.number_field().gen()
             sage: G.discrete_log(4, 3 + 2*s)
-            [5, 1, 1, 1]
-            sage: gs = G.unit_gens(4); gs[0]^5 * gs[1] * gs[2] * gs[3] - (3 + 2*s) in G.ideal(4)
+            [1, 2, 2, 1]
+            sage: gs = G.unit_gens(4); gs[0] * gs[1]^2 * gs[2]^2 * gs[3] - (3 + 2*s) in G.ideal(4)
             True
         """
         x = self.number_field().coerce(x)
diff --git a/src/sage/modular/modform/find_generators.py b/src/sage/modular/modform/find_generators.py
index 18055ef00f..40f4f7c858 100644
--- a/src/sage/modular/modform/find_generators.py
+++ b/src/sage/modular/modform/find_generators.py
@@ -400,8 +400,7 @@ class ModularFormsRing(SageObject):
             sage: ModularFormsRing(Gamma0(13)).generators(maxweight=12, prec=4)
             [(2, 1 + 2*q + 6*q^2 + 8*q^3 + O(q^4)), (4, 1 + O(q^4)), (4, q + O(q^4)), (4, q^2 + O(q^4)), (4, q^3 + O(q^4)), (6, 1 + O(q^4)), (6, q + O(q^4))]
             sage: ModularFormsRing(Gamma0(13),base_ring=ZZ).generators(maxweight=12, prec=4)
-            [(2, 1 + 2*q + 6*q^2 + 8*q^3 + O(q^4)), (4, O(q^4)), (4, q^3 + O(q^4)), (4, q^2 + O(q^4)), (4, q + O(q^4)), (6, O(q^4)), (6, O(q^4)), (12, O(q^4))]
-
+            [(2, 1 + 2*q + 6*q^2 + 8*q^3 + O(q^4)), (4, q + 4*q^2 + 10*q^3 + O(q^4)), (4, 2*q^2 + 5*q^3 + O(q^4)), (4, q^2 + O(q^4)), (4, -2*q^3 + O(q^4)), (6, O(q^4)), (6, O(q^4)), (12, O(q^4))]
             sage: [k for k,f in ModularFormsRing(1, QQ).generators(maxweight=12)]
             [4, 6]
             sage: [k for k,f in ModularFormsRing(1, ZZ).generators(maxweight=12)]
diff --git a/src/sage/modular/modsym/p1list_nf.py b/src/sage/modular/modsym/p1list_nf.py
index 709a91035a..91f7efada6 100644
--- a/src/sage/modular/modsym/p1list_nf.py
+++ b/src/sage/modular/modsym/p1list_nf.py
@@ -957,7 +957,7 @@ class P1NFList(SageObject):
             sage: N = k.ideal(a + 1)
             sage: P = P1NFList(N)
             sage: u = k.unit_group().gens_values(); u
-            [-1, a^3 + a^2 + a + 12, a^3 + 3*a^2 - 1]
+            [-1, -a^3 - a^2 - a - 12, -a^3 - 3*a^2 + 1]
             sage: P.apply_J_epsilon(3, u[2]^2)==P.apply_J_epsilon(P.apply_J_epsilon(3, u[2]),u[2])
             True
         """
diff --git a/src/sage/modular/multiple_zeta.py b/src/sage/modular/multiple_zeta.py
index 67c46766c8..d1f1f55024 100644
--- a/src/sage/modular/multiple_zeta.py
+++ b/src/sage/modular/multiple_zeta.py
@@ -458,7 +458,7 @@ class MultizetaValues(UniqueRepresentation):
         """
         self.prec = int(prec)
         self.max_weight = int(max_weight)
-        self._data = pari.zetamultall(self.max_weight, self.prec)
+        self._data = pari.zetamultall(self.max_weight, precision=self.prec)
 
     def update(self, max_weight, prec):
         """
diff --git a/src/sage/modules/fg_pid/fgp_element.py b/src/sage/modules/fg_pid/fgp_element.py
index 53857d31a0..5a948b6152 100644
--- a/src/sage/modules/fg_pid/fgp_element.py
+++ b/src/sage/modules/fg_pid/fgp_element.py
@@ -39,7 +39,7 @@ class FGP_Element(ModuleElement):
         sage: V = span([[1/2,1,1],[3/2,2,1],[0,0,1]],ZZ); W = V.span([2*V.0+4*V.1, 9*V.0+12*V.1, 4*V.2])
         sage: Q = V/W
         sage: x = Q(V.0-V.1); x #indirect doctest
-        (0, 3)
+        (0, 9)
         sage: isinstance(x, sage.modules.fg_pid.fgp_element.FGP_Element)
         True
         sage: type(x)
@@ -94,14 +94,14 @@ class FGP_Element(ModuleElement):
             sage: Q.1
             (0, 1)
             sage: Q.0.lift()
-            (0, 0, 1)
+            (0, 6, 1)
             sage: Q.1.lift()
-            (0, 2, 0)
+            (0, -2, 0)
             sage: x = Q(V.0); x
-            (0, 4)
+            (0, 8)
             sage: x.lift()
             (1/2, 0, 0)
-            sage: x == 4*Q.1
+            sage: x == 8*Q.1
             True
             sage: x.lift().parent() == V
             True
@@ -158,9 +158,9 @@ class FGP_Element(ModuleElement):
         We test canonical coercion from V and W.
 
             sage: Q.0 + V.0
-            (1, 4)
+            (1, 8)
             sage: V.0 + Q.0
-            (1, 4)
+            (1, 8)
             sage: W.0 + Q.0
             (1, 0)
             sage: W.0 + Q.0 == Q.0
@@ -291,7 +291,7 @@ class FGP_Element(ModuleElement):
             sage: V = span([[1/2,1,1],[3/2,2,1],[0,0,1]],ZZ); W = V.span([2*V.0+4*V.1, 9*V.0+12*V.1, 4*V.2])
             sage: Q = V/W
             sage: Q(V.1)._repr_()
-            '(0, 1)'
+            '(0, 11)'
         """
         return repr(self.vector())
 
diff --git a/src/sage/modules/fg_pid/fgp_module.py b/src/sage/modules/fg_pid/fgp_module.py
index 38b95d40a3..935d0ab5c0 100644
--- a/src/sage/modules/fg_pid/fgp_module.py
+++ b/src/sage/modules/fg_pid/fgp_module.py
@@ -70,17 +70,17 @@ the technical note has a V that need not be equal to V0, in general. ::
     sage: M0.optimized()[0].V()
     Free module of degree 3 and rank 2 over Integer Ring
     User basis matrix:
-    [0 0 1]
-    [0 2 0]
+    [ 0  8  1]
+    [ 0 -2  0]
 
 Create elements of M0 either by coercing in elements of V0, getting generators,
 or coercing in a list or tuple or coercing in 0. Finally, one can express an
 element as a linear combination of the smith form generators ::
 
     sage: M0(V0.0)
-    (0, 14)
+    (0, 2)
     sage: M0(V0.0 + W0.0)  # no difference modulo W0
-    (0, 14)
+    (0, 2)
     sage: M0.linear_combination_of_smith_form_gens([3,20])
     (3, 4)
     sage: 3*M0.0 + 20*M0.1
@@ -93,9 +93,9 @@ coerces to V0, then take the equivalence class modulo W0. ::
     sage: x = M0.0 - M0.1; x
     (1, 15)
     sage: x.lift()
-    (0, -2, 1)
+    (0, 10, 1)
     sage: M0(vector([1/2,0,0]))
-    (0, 14)
+    (0, 2)
     sage: x.additive_order()
     16
 
@@ -142,9 +142,9 @@ You can explicitly coerce elements of the kernel into M0 though. ::
     Finitely generated module V/W over Integer Ring with invariants (2, 16)
 
     sage: M0(K.0)
-    (2, 0)
+    (2, 8)
     sage: M0(K.1)
-    (3, 1)
+    (1, 5)
     sage: f(M0(K.0))
     (0)
     sage: f(M0(K.1))
@@ -180,7 +180,7 @@ TESTS::
     sage: Q.linear_combination_of_smith_form_gens([1,3])
     (1, 3)
     sage: Q(V([1,3,4]))
-    (0, 11)
+    (0, 1)
     sage: Q(W([1,16,0]))
     (0, 0)
     sage: V = span([[1/2,1,1],[3/2,2,1],[0,0,1]],QQ)
@@ -632,7 +632,7 @@ class FGP_Module_class(Module):
             sage: W = V.span([2*V.0+4*V.1, 9*V.0+12*V.1, 4*V.2])
             sage: Q = V/W
             sage: x = Q(V.0-V.1); x  # indirect doctest
-            (0, 3)
+            (0, 9)
             sage: type(x)
             <class 'sage.modules.fg_pid.fgp_module.FGP_Module_class_with_category.element_class'>
             sage: x is Q(x)
@@ -931,9 +931,9 @@ class FGP_Module_class(Module):
             sage: Q = V/W
             sage: Q._smith_form()
             (
-            [ 1  0  0]  [1 0 0]  [ 1  0 -8]
-            [ 0  4  0]  [0 0 1]  [ 0  0  1]
-            [ 0  0 12], [0 1 0], [ 0  1  0]
+            [ 1  0  0]  [ 1  0  0]  [ 1  0  8]
+            [ 0  4  0]  [ 0  1  1]  [ 0  0 -1]
+            [ 0  0 12], [ 0 -1  0], [ 0  1  3]
             )
         """
         return self._relative_matrix().smith_form()
@@ -1026,7 +1026,7 @@ class FGP_Module_class(Module):
             sage: Q.smith_form_gens()
             ((1, 0), (0, 1))
             sage: [x.lift() for x in Q.smith_form_gens()]
-            [(0, 0, 1), (0, 1, 0)]
+            [(0, 3, 1), (0, -1, 0)]
         """
         # Get the rightmost transformation in the Smith form
         _, _, X = self._smith_form()
@@ -1069,15 +1069,15 @@ class FGP_Module_class(Module):
             sage: D.gens_to_smith()
             [0 3 0]
             [0 0 3]
-            [0 2 0]
-            [1 0 0]
+            [0 4 0]
+            [1 2 0]
             [0 0 4]
             sage: T = D.gens_to_smith()*D.smith_to_gens()
             sage: T
-            [ 3  0 15  0  0]
+            [ 3  0  3  0  0]
             [ 0 33  0  0  3]
-            [ 2  0 10  0  0]
-            [ 0  0  0  1  0]
+            [ 4  0  4  0  0]
+            [ 2  0  3  1  0]
             [ 0 44  0  0  4]
 
         The matrix `T` now satisfies a certain congruence::
@@ -1120,13 +1120,13 @@ class FGP_Module_class(Module):
             [  0   0   0 1/3   0]
             [  0   0   0   0 2/3]
             sage: D.smith_to_gens()
-            [ 0  0  0  1  0]
-            [ 1  0  5  0  0]
+            [ 0  0  1  1  0]
+            [ 1  0  1  0  0]
             [ 0 11  0  0  1]
             sage: T = D.smith_to_gens()*D.gens_to_smith()
             sage: T
-            [ 1  0  0]
-            [ 0 13  0]
+            [ 1  6  0]
+            [ 0  7  0]
             [ 0  0 37]
 
         This matrix satisfies the congruence::
@@ -1148,7 +1148,7 @@ class FGP_Module_class(Module):
         of the user defined generators that is x::
 
             sage: x.vector() * D.smith_to_gens()
-            (2, 33, 10, 1, 3)
+            (2, 33, 3, 1, 3)
         """
         if self.base_ring() != ZZ:
             # it is not
@@ -1196,7 +1196,7 @@ class FGP_Module_class(Module):
              sage: gens = [V(g) for g in gens]
              sage: D = FGP_with_gens(V, W, gens)
              sage: D.gens()
-             ((0, 3, 0), (0, 0, 3), (0, 2, 0), (1, 0, 0), (0, 0, 8))
+             ((0, 3, 0), (0, 0, 3), (0, 4, 0), (1, 2, 0), (0, 0, 8))
 
 
         We create some element of D::
@@ -1209,12 +1209,12 @@ class FGP_Module_class(Module):
 
             sage: v = D.gens_vector(x)
             sage: v
-            (2, 9, 10, 1, 33)
+            (2, 9, 3, 1, 33)
 
         The output can be further reduced::
 
             sage: D.gens_vector(x, reduce=True)
-            (0, 1, 1, 1, 0)
+            (0, 1, 0, 1, 0)
 
         Let us check::
 
@@ -1262,9 +1262,9 @@ class FGP_Module_class(Module):
         If x is not in self, it is coerced in::
 
             sage: Q.coordinate_vector(V.0)
-            (1, 0, -3)
+            (1, -3, 0)
             sage: Q.coordinate_vector(Q(V.0))
-            (1, 0, -3)
+            (1, -3, 0)
 
         TESTS::
 
@@ -1278,28 +1278,28 @@ class FGP_Module_class(Module):
             sage: O.V()
             Free module of degree 3 and rank 2 over Integer Ring
             User basis matrix:
-            [0 0 1]
-            [0 2 0]
+            [ 0  6  1]
+            [ 0 -2  0]
             sage: phi = Q.hom([Q.0, 4*Q.1])
             sage: x = Q(V.0); x
-            (0, 4)
+            (0, 8)
             sage: Q.coordinate_vector(x, reduce=True)
-            (0, 4)
+            (0, 8)
             sage: Q.coordinate_vector(-x, reduce=False) # random
-            (0, -4)
-            sage: x == 4*Q.1
+            (0, -8)
+            sage: x == 8*Q.1
             True
             sage: x = Q(V.1); x
-            (0, 1)
+            (0, 11)
             sage: Q.coordinate_vector(x)
-            (0, 1)
-            sage: x == Q.1
+            (0, -1)
+            sage: x == -Q.1
             True
             sage: x = Q(V.2); x
-            (1, 0)
+            (1, 3)
             sage: Q.coordinate_vector(x)
-            (1, 0)
-            sage: x == Q.0
+            (1, 3)
+            sage: x == Q.0 + 3*Q.1
             True
         """
         try:
@@ -1407,8 +1407,8 @@ class FGP_Module_class(Module):
             sage: O.V()
             Free module of degree 3 and rank 2 over Integer Ring
             User basis matrix:
-            [0 0 1]
-            [0 1 0]
+            [ 0  3  1]
+            [ 0 -1  0]
             sage: O.W()
             Free module of degree 3 and rank 2 over Integer Ring
             Echelon basis matrix:
@@ -1699,7 +1699,7 @@ class FGP_Module_class(Module):
             sage: V = span([[1/2,1,1],[3/2,2,1],[0,0,1]],ZZ); W = V.span([2*V.0+4*V.1, 9*V.0+12*V.1, 4*V.2])
             sage: Q = V/W
             sage: Q.random_element()
-            (1, 10)
+            (1, 5)
         """
         return self(self._V.random_element(*args, **kwds))
 
diff --git a/src/sage/modules/fg_pid/fgp_morphism.py b/src/sage/modules/fg_pid/fgp_morphism.py
index fbbd479c6e..ce5df8df52 100644
--- a/src/sage/modules/fg_pid/fgp_morphism.py
+++ b/src/sage/modules/fg_pid/fgp_morphism.py
@@ -258,20 +258,20 @@ class FGP_Morphism(Morphism):
             sage: O.V()
             Free module of degree 3 and rank 2 over Integer Ring
             User basis matrix:
-            [0 0 1]
-            [0 2 0]
+            [ 0  6  1]
+            [ 0 -2  0]
             sage: phi = Q.hom([Q.0, 4*Q.1])
             sage: x = Q(V.0); x
-            (0, 4)
-            sage: x == 4*Q.1
+            (0, 8)
+            sage: x == 8*Q.1
             True
             sage: x in O.V()
             False
             sage: phi(x)
-            (0, 4)
-            sage: phi(4*Q.1)
-            (0, 4)
-            sage: phi(4*Q.1) == phi(x)
+            (0, 8)
+            sage: phi(8*Q.1)
+            (0, 8)
+            sage: phi(8*Q.1) == phi(x)
             True
         """
         from .fgp_module import is_FGP_Module
diff --git a/src/sage/modules/free_quadratic_module_integer_symmetric.py b/src/sage/modules/free_quadratic_module_integer_symmetric.py
index 7de14e8d77..d09578682e 100644
--- a/src/sage/modules/free_quadratic_module_integer_symmetric.py
+++ b/src/sage/modules/free_quadratic_module_integer_symmetric.py
@@ -549,8 +549,8 @@ def IntegralLatticeGluing(Lattices, glue, return_embeddings=False):
         sage: [L, phi] = IntegralLatticeGluing([L1, L2], [[f1, g1], [f2, 2 * g2]], True)
         sage: phi[0]
         Free module morphism defined by the matrix
-        [ 2  2 -1 -2]
-        [ 0  2  0 -1]
+        [ 2  2 -2 -1]
+        [ 0  2 -1  0]
         Domain: Lattice of degree 4 and rank 2 over Integer Ring
         Basis matrix:
         [1 1 0 0]
@@ -563,7 +563,7 @@ def IntegralLatticeGluing(Lattices, glue, return_embeddings=False):
         Codomain: Lattice of degree 10 and rank 4 over Integer Ring
         Basis matrix:
         [ 1/2    0 -1/2    0    0  1/2    0    0  1/2  1/2]
-        [   0  1/2  1/2    0    0    0    0    0  1/2  1/2]
+        [   0  1/2  1/2    0    0  1/2    0    0    0    0]
         [   0    0    0    0    0    1    0    0    0    0]
         [   0    0    0    0    0    0    0    0    1    1]
         Inner product matrix:
@@ -784,7 +784,7 @@ class FreeQuadraticModule_integer_symmetric(FreeQuadraticModule_submodule_with_b
             Finite quadratic module over Integer Ring with invariants (2, 10)
             Gram matrix of the quadratic form with values in Q/2Z:
             [  1 1/2]
-            [1/2 9/5]
+            [1/2 1/5]
             sage: L.discriminant_group(2)
             Finite quadratic module over Integer Ring with invariants (2, 2)
             Gram matrix of the quadratic form with values in Q/2Z:
@@ -793,7 +793,7 @@ class FreeQuadraticModule_integer_symmetric(FreeQuadraticModule_submodule_with_b
             sage: L.discriminant_group(5)
             Finite quadratic module over Integer Ring with invariants (5,)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [6/5]
+            [4/5]
 
         TESTS::
 
@@ -1463,8 +1463,8 @@ def local_modification(M, G, p, check=True):
         sage: local_modification(M, L.gram_matrix(), 2)
         Lattice of degree 4 and rank 4 over Integer Ring
         Basis matrix:
-        [1/3   0 1/3 2/3]
-        [  0 1/3 1/3 2/3]
+        [1/3   0 2/3 2/3]
+        [  0 1/3   0 2/3]
         [  0   0   1   0]
         [  0   0   0   1]
         Inner product matrix:
diff --git a/src/sage/modules/torsion_quadratic_module.py b/src/sage/modules/torsion_quadratic_module.py
index 27a019554e..f922c0c278 100644
--- a/src/sage/modules/torsion_quadratic_module.py
+++ b/src/sage/modules/torsion_quadratic_module.py
@@ -62,7 +62,7 @@ def TorsionQuadraticForm(q):
 
     TESTS::
 
-        sage: TorsionQuadraticForm(matrix.diagonal([3/8,3/8,3/4]))
+        sage: TorsionQuadraticForm(matrix.diagonal([3/4,3/8,3/8]))
         Finite quadratic module over Integer Ring with invariants (4, 8, 8)
         Gram matrix of the quadratic form with values in Q/2Z:
         [3/4   0   0]
@@ -1030,10 +1030,10 @@ class TorsionQuadraticModule(FGP_Module_class, CachedRepresentation):
             sage: T
             Finite quadratic module over Integer Ring with invariants (6, 6, 12, 12)
             Gram matrix of the quadratic form with values in Q/(1/3)Z:
-            [1/18 5/36    0    0]
-            [5/36 1/18 5/36 5/36]
-            [   0 5/36 1/36 1/72]
-            [   0 5/36 1/72 1/36]
+            [ 1/18  1/12  5/36  1/36]
+            [ 1/12   1/6  1/36   1/9]
+            [ 5/36  1/36  1/36 11/72]
+            [ 1/36   1/9 11/72  1/36]
             sage: T.normal_form()
             Finite quadratic module over Integer Ring with invariants (6, 6, 12, 12)
             Gram matrix of the quadratic form with values in Q/(1/3)Z:
diff --git a/src/sage/quadratic_forms/extras.py b/src/sage/quadratic_forms/extras.py
index 37c30e9afa..2baa4e3cfa 100644
--- a/src/sage/quadratic_forms/extras.py
+++ b/src/sage/quadratic_forms/extras.py
@@ -94,12 +94,12 @@ def extend_to_primitive(A_input):
 
         sage: A = Matrix(ZZ, 3, 2, range(6))
         sage: extend_to_primitive(A)
-        [ 0  1  0]
+        [ 0  1 -1]
         [ 2  3  0]
-        [ 4  5 -1]
+        [ 4  5  0]
 
         sage: extend_to_primitive([vector([1,2,3])])
-        [(1, 2, 3), (0, 1, 0), (0, 0, 1)]
+        [(1, 2, 3), (0, 1, 1), (-1, 0, 0)]
 
     """
     ## Deal with a list of vectors
diff --git a/src/sage/quadratic_forms/genera/genus.py b/src/sage/quadratic_forms/genera/genus.py
index f0718593ea..35de7eea8d 100644
--- a/src/sage/quadratic_forms/genera/genus.py
+++ b/src/sage/quadratic_forms/genera/genus.py
@@ -2897,18 +2897,18 @@ class GenusSymbol_global_ring(object):
             sage: GS.discriminant_form()
             Finite quadratic module over Integer Ring with invariants (2, 2, 4, 24)
             Gram matrix of the quadratic form with values in Q/2Z:
-            [ 1/2    0    0    0]
-            [   0  3/2    0    0]
-            [   0    0  7/4    0]
-            [   0    0    0 7/24]
+            [  1/2     0   1/2     0]
+            [    0   3/2     0     0]
+            [  1/2     0   3/4     0]
+            [    0     0     0 25/24]
             sage: A = matrix.diagonal(ZZ, [1, -4, 6, 8])
             sage: GS = Genus(A)
             sage: GS.discriminant_form()
             Finite quadratic module over Integer Ring with invariants (2, 4, 24)
             Gram matrix of the quadratic form with values in Q/Z:
-            [ 1/2    0    0]
-            [   0  3/4    0]
-            [   0    0 7/24]
+            [ 1/2  1/2    0]
+            [ 1/2  3/4    0]
+            [   0    0 1/24]
         """
         from sage.modules.torsion_quadratic_module import TorsionQuadraticForm
         qL = []
diff --git a/src/sage/quadratic_forms/quadratic_form__split_local_covering.py b/src/sage/quadratic_forms/quadratic_form__split_local_covering.py
index 92102fcbd1..85abc20a86 100644
--- a/src/sage/quadratic_forms/quadratic_form__split_local_covering.py
+++ b/src/sage/quadratic_forms/quadratic_form__split_local_covering.py
@@ -318,25 +318,25 @@ def complementary_subform_to_vector(self, v):
         sage: Q1 = DiagonalQuadraticForm(ZZ, [1,3,5,7])
         sage: Q1.complementary_subform_to_vector([1,0,0,0])
         Quadratic form in 3 variables over Integer Ring with coefficients:
-        [ 3 0 0 ]
+        [ 7 0 0 ]
         [ * 5 0 ]
-        [ * * 7 ]
+        [ * * 3 ]
 
     ::
 
         sage: Q1.complementary_subform_to_vector([1,1,0,0])
         Quadratic form in 3 variables over Integer Ring with coefficients:
-        [ 12 0 0 ]
+        [ 7 0 0 ]
         [ * 5 0 ]
-        [ * * 7 ]
+        [ * * 12 ]
 
     ::
 
         sage: Q1.complementary_subform_to_vector([1,1,1,1])
         Quadratic form in 3 variables over Integer Ring with coefficients:
-        [ 624 -480 -672 ]
-        [ * 880 -1120 ]
-        [ * * 1008 ]
+        [ 880 -480 -160 ]
+        [ * 624 -96 ]
+        [ * * 240 ]
 
     """
     n = self.dim()
@@ -417,8 +417,8 @@ def split_local_cover(self):
         sage: Q1.split_local_cover()
         Quadratic form in 3 variables over Integer Ring with coefficients:
         [ 3 0 0 ]
-        [ * 7 0 ]
-        [ * * 5 ]
+        [ * 5 0 ]
+        [ * * 7 ]
 
     """
     ## 0. If a split local cover already exists, then return it.
diff --git a/src/sage/rings/finite_rings/finite_field_base.pyx b/src/sage/rings/finite_rings/finite_field_base.pyx
index 972f07e6de..124d9cfd56 100644
--- a/src/sage/rings/finite_rings/finite_field_base.pyx
+++ b/src/sage/rings/finite_rings/finite_field_base.pyx
@@ -1621,14 +1621,14 @@ cdef class FiniteField(Field):
 
         We check that :trac:`23801` is resolved::
 
-            sage: k.<a> = GF(3^240)
+            sage: k.<a> = GF(5^240)
             sage: l, inc = k.subfield(3, 'z', map=True); l
-            Finite Field in z of size 3^3
+            Finite Field in z of size 5^3
             sage: inc
             Ring morphism:
-              From: Finite Field in z of size 3^3
-              To:   Finite Field in a of size 3^240
-              Defn: z |--> a^239 + a^238 + ... + a^3 + 2
+              From: Finite Field in z of size 5^3
+              To:   Finite Field in a of size 5^240
+              Defn: z |--> 2*a^235 + a^231 + ... + a + 4
 
         There is no coercion since we can't ensure compatibility with larger
         fields in this case::
@@ -1639,7 +1639,7 @@ cdef class FiniteField(Field):
         But there is still a compatibility among the generators chosen for the subfields::
 
             sage: ll, iinc = k.subfield(12, 'w', map=True)
-            sage: x = iinc(ll.gen())^((3^12-1)/(3^3-1))
+            sage: x = iinc(ll.gen())^((5^12-1)/(5^3-1))
             sage: x.minimal_polynomial() == l.modulus()
             True
 
diff --git a/src/sage/rings/finite_rings/finite_field_constructor.py b/src/sage/rings/finite_rings/finite_field_constructor.py
index 04073fc52a..48c5a78302 100644
--- a/src/sage/rings/finite_rings/finite_field_constructor.py
+++ b/src/sage/rings/finite_rings/finite_field_constructor.py
@@ -284,14 +284,14 @@ class FiniteFieldFactory(UniqueFactory):
     (a generator of the multiplicative group), use
     ``modulus="primitive"`` if you need this::
 
-        sage: K.<a> = GF(5^40)
+        sage: K.<a> = GF(5^45)
         sage: a.multiplicative_order()
-        189478062869360049565633138
+        7105427357601001858711242675781
         sage: a.is_square()
         True
-        sage: K.<b> = GF(5^40, modulus="primitive")
+        sage: K.<b> = GF(5^45, modulus="primitive")
         sage: b.multiplicative_order()
-        9094947017729282379150390624
+        28421709430404007434844970703124
 
     The modulus must be irreducible::
 
diff --git a/src/sage/rings/finite_rings/integer_mod_ring.py b/src/sage/rings/finite_rings/integer_mod_ring.py
index 0dcef0d21a..8380acc653 100644
--- a/src/sage/rings/finite_rings/integer_mod_ring.py
+++ b/src/sage/rings/finite_rings/integer_mod_ring.py
@@ -626,7 +626,7 @@ class IntegerModRing_generic(quotient_ring.QuotientRing_generic):
             sage: Integers(5).multiplicative_subgroups()
             ((2,), (4,), ())
             sage: Integers(15).multiplicative_subgroups()
-            ((11, 7), (4, 11), (8,), (11,), (14,), (7,), (4,), ())
+            ((11, 7), (11, 4), (2,), (11,), (14,), (7,), (4,), ())
             sage: Integers(2).multiplicative_subgroups()
             ((),)
             sage: len(Integers(341).multiplicative_subgroups())
diff --git a/src/sage/rings/finite_rings/residue_field.pyx b/src/sage/rings/finite_rings/residue_field.pyx
index cd4c2212c3..007a68e4c0 100644
--- a/src/sage/rings/finite_rings/residue_field.pyx
+++ b/src/sage/rings/finite_rings/residue_field.pyx
@@ -1055,7 +1055,7 @@ cdef class ReductionMap(Map):
             sage: f = k.convert_map_from(K)
             sage: s = f.section(); s
             Lifting map:
-              From: Residue field in abar of Fractional ideal (14*a^4 - 24*a^3 - 26*a^2 + 58*a - 15)
+              From: Residue field in abar of Fractional ideal (-14*a^4 + 24*a^3 + 26*a^2 - 58*a + 15)
               To:   Number Field in a with defining polynomial x^5 - 5*x + 2
             sage: s(k.gen())
             a
@@ -1268,7 +1268,7 @@ cdef class ResidueFieldHomomorphism_global(RingHomomorphism):
             sage: f = k.coerce_map_from(K.ring_of_integers())
             sage: s = f.section(); s
             Lifting map:
-              From: Residue field in abar of Fractional ideal (14*a^4 - 24*a^3 - 26*a^2 + 58*a - 15)
+              From: Residue field in abar of Fractional ideal (-14*a^4 + 24*a^3 + 26*a^2 - 58*a + 15)
               To:   Maximal Order in Number Field in a with defining polynomial x^5 - 5*x + 2
             sage: s(k.gen())
             a
@@ -1371,10 +1371,10 @@ cdef class LiftingMap(Section):
             sage: F = K.factor(7)[0][0].residue_field()
             sage: L = F.lift_map(); L
             Lifting map:
-              From: Residue field in abar of Fractional ideal (-2*a^4 + a^3 - 4*a^2 + 2*a - 1)
+              From: Residue field in abar of Fractional ideal (2*a^4 - a^3 + 4*a^2 - 2*a + 1)
               To:   Maximal Order in Number Field in a with defining polynomial x^5 + 2
             sage: L.domain()
-            Residue field in abar of Fractional ideal (-2*a^4 + a^3 - 4*a^2 + 2*a - 1)
+            Residue field in abar of Fractional ideal (2*a^4 - a^3 + 4*a^2 - 2*a + 1)
 
             sage: K.<a> = CyclotomicField(7)
             sage: F = K.factor(5)[0][0].residue_field()
@@ -1498,7 +1498,7 @@ cdef class LiftingMap(Section):
             sage: F.<tmod> = K.factor(7)[0][0].residue_field()
             sage: F.lift_map() #indirect doctest
             Lifting map:
-              From: Residue field in tmod of Fractional ideal (-3*theta_12^2 + 1)
+              From: Residue field in tmod of Fractional ideal (theta_12^2 + 2)
               To:   Maximal Order in Cyclotomic Field of order 12 and degree 4
         """
         return "Lifting"
@@ -1515,7 +1515,7 @@ class ResidueFiniteField_prime_modn(ResidueField_generic, FiniteField_prime_modn
         sage: P = K.ideal(29).factor()[1][0]
         sage: k = ResidueField(P)
         sage: k
-        Residue field of Fractional ideal (a^2 + 2*a + 2)
+        Residue field of Fractional ideal (-a^2 - 2*a - 2)
         sage: k.order()
         29
         sage: OK = K.maximal_order()
@@ -1597,7 +1597,7 @@ class ResidueFiniteField_prime_modn(ResidueField_generic, FiniteField_prime_modn
             sage: P = K.ideal(29).factor()[1][0]
             sage: k = ResidueField(P)
             sage: k
-            Residue field of Fractional ideal (a^2 + 2*a + 2)
+            Residue field of Fractional ideal (-a^2 - 2*a - 2)
             sage: OK = K.maximal_order()
             sage: c = OK(a)
             sage: b = k(a); b
diff --git a/src/sage/rings/integer.pyx b/src/sage/rings/integer.pyx
index a2f913df7f..0bae1cc505 100644
--- a/src/sage/rings/integer.pyx
+++ b/src/sage/rings/integer.pyx
@@ -5474,7 +5474,7 @@ cdef class Integer(sage.structure.element.EuclideanDomainElement):
             sage: 3._bnfisnorm(QuadraticField(-1, 'i'))
             (1, 3)
             sage: 7._bnfisnorm(CyclotomicField(7))
-            (-zeta7^5 - zeta7^4 - 2*zeta7^3 - zeta7^2 - zeta7 - 1, 1)
+            (zeta7^5 - zeta7^2, 1)
         """
         from sage.rings.rational_field import QQ
         return QQ(self)._bnfisnorm(K, proof=proof, extra_primes=extra_primes)
diff --git a/src/sage/rings/number_field/S_unit_solver.py b/src/sage/rings/number_field/S_unit_solver.py
index 5c0a33eb74..ccd088d630 100644
--- a/src/sage/rings/number_field/S_unit_solver.py
+++ b/src/sage/rings/number_field/S_unit_solver.py
@@ -24,10 +24,10 @@ EXAMPLES::
     sage: from sage.rings.number_field.S_unit_solver import solve_S_unit_equation, eq_up_to_order
     sage: K.<xi> = NumberField(x^2+x+1)
     sage: S = K.primes_above(3)
-    sage: expected = [((2, 1), (4, 0), xi + 2, -xi - 1),
-    ....:             ((5, -1), (4, -1), 1/3*xi + 2/3, -1/3*xi + 1/3),
-    ....:             ((5, 0), (1, 0), -xi, xi + 1),
-    ....:             ((1, 1), (2, 0), -xi + 1, xi)]
+    sage: expected = [((0, 1), (4, 0), xi + 2, -xi - 1),
+    ....:             ((1, -1), (0, -1), 1/3*xi + 2/3, -1/3*xi + 1/3),
+    ....:             ((1, 0), (5, 0), xi + 1, -xi),
+    ....:             ((2, 0), (5, 1), xi, -xi + 1)]
     sage: sols = solve_S_unit_equation(K, S, 200)
     sage: eq_up_to_order(sols, expected)
     True
@@ -1780,20 +1780,20 @@ def sieve_ordering(SUK, q):
         sage: SUK = K.S_unit_group(S=3)
         sage: sieve_data = list(sieve_ordering(SUK, 19))
         sage: sieve_data[0]
-        (Fractional ideal (-2*xi^2 + 3),
-        Fractional ideal (xi - 3),
-        Fractional ideal (2*xi + 1))
+        (Fractional ideal (xi - 3),
+         Fractional ideal (-2*xi^2 + 3),
+         Fractional ideal (2*xi + 1))
 
         sage: sieve_data[1]
-        (Residue field of Fractional ideal (-2*xi^2 + 3),
-        Residue field of Fractional ideal (xi - 3),
-        Residue field of Fractional ideal (2*xi + 1))
+        (Residue field of Fractional ideal (xi - 3),
+         Residue field of Fractional ideal (-2*xi^2 + 3),
+         Residue field of Fractional ideal (2*xi + 1))
 
         sage: sieve_data[2]
-        ([18, 9, 16, 8], [18, 7, 10, 4], [18, 3, 12, 10])
+        ([18, 7, 16, 4], [18, 9, 12, 8], [18, 3, 10, 10])
 
         sage: sieve_data[3]
-        (972, 972, 3888)
+        (486, 648, 11664)
     """
 
     K = SUK.number_field()
@@ -2654,10 +2654,10 @@ def sieve_below_bound(K, S, bound=10, bump=10, split_primes_list=[], verbose=Fal
         sage: S = SUK.primes()
         sage: sols = sieve_below_bound(K, S, 10)
         sage: expected = [
-        ....: ((5, -1), (4, -1), 1/3*xi + 2/3, -1/3*xi + 1/3),
-        ....: ((2, 1), (4, 0), xi + 2, -xi - 1),
-        ....: ((2, 0), (1, 1), xi, -xi + 1),
-        ....: ((5, 0), (1, 0), -xi, xi + 1)]
+        ....: ((1, -1), (0, -1), 1/3*xi + 2/3, -1/3*xi + 1/3),
+        ....: ((0, 1), (4, 0), xi + 2, -xi - 1),
+        ....: ((2, 0), (5, 1), xi, -xi + 1),
+        ....: ((1, 0), (5, 0), xi + 1, -xi)]
         sage: eq_up_to_order(sols, expected)
         True
     """
@@ -2715,10 +2715,10 @@ def solve_S_unit_equation(K, S, prec=106, include_exponents=True, include_bound=
         sage: S = K.primes_above(3)
         sage: sols = solve_S_unit_equation(K, S, 200)
         sage: expected = [
-        ....: ((2, 1), (4, 0), xi + 2, -xi - 1),
-        ....: ((5, -1), (4, -1), 1/3*xi + 2/3, -1/3*xi + 1/3),
-        ....: ((5, 0), (1, 0), -xi, xi + 1),
-        ....: ((1, 1), (2, 0), -xi + 1, xi)]
+        ....: ((0, 1), (4, 0), xi + 2, -xi - 1),
+        ....: ((1, -1), (0, -1), 1/3*xi + 2/3, -1/3*xi + 1/3),
+        ....: ((1, 0), (5, 0), xi + 1, -xi),
+        ....: ((2, 0), (5, 1), xi, -xi + 1)]
         sage: eq_up_to_order(sols, expected)
         True
 
@@ -2726,7 +2726,7 @@ def solve_S_unit_equation(K, S, prec=106, include_exponents=True, include_bound=
 
         sage: solutions, bound = solve_S_unit_equation(K, S, 100, include_bound=True)
         sage: bound
-        6
+        7
 
     You can omit the exponent vectors::
 
diff --git a/src/sage/rings/number_field/class_group.py b/src/sage/rings/number_field/class_group.py
index 46d0ca8c9d..1ad6d583a8 100644
--- a/src/sage/rings/number_field/class_group.py
+++ b/src/sage/rings/number_field/class_group.py
@@ -157,7 +157,7 @@ class FractionalIdealClass(AbelianGroupWithValuesElement):
             sage: C=K.class_group()
             sage: c = C(2, a)
             sage: c^2
-            Fractional ideal class (2, a^2 + 2*a - 1)
+            Fractional ideal class (4, a)
             sage: c^3
             Trivial principal fractional ideal class
             sage: c^1000
@@ -467,7 +467,7 @@ class ClassGroup(AbelianGroupWithValues_class):
             sage: CK = K.class_group()
             sage: CL = L.class_group()
             sage: [CL(I).exponents() for I in CK]
-            [(0,), (4,), (2,)]
+            [(0,), (2,), (4,)]
         """
         if isinstance(args[0], FractionalIdealClass):
             return self.element_class(self, None, self._number_field.ideal(args[0].ideal()))
diff --git a/src/sage/rings/number_field/number_field.py b/src/sage/rings/number_field/number_field.py
index f4cdb9e4f3..70a142ba5c 100644
--- a/src/sage/rings/number_field/number_field.py
+++ b/src/sage/rings/number_field/number_field.py
@@ -3590,7 +3590,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
             sage: L.<b> = K.extension(x^2 - 3, x^2 + 1)
             sage: M.<c> = L.extension(x^2 + 1)
             sage: L.ideal(K.ideal(2, a))
-            Fractional ideal (a)
+            Fractional ideal (-a)
             sage: M.ideal(K.ideal(2, a)) == M.ideal(a*(b - c)/2)
             True
 
@@ -4758,7 +4758,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
              1/13*a^2 + 7/13*a - 332/13,
              -1/13*a^2 + 6/13*a + 345/13,
              -1,
-             2/13*a^2 + 1/13*a - 755/13]
+             -2/13*a^2 - 1/13*a + 755/13]
             sage: units[5] in (1/13*a^2 - 19/13*a - 7/13, 1/13*a^2 + 20/13*a - 7/13)
             True
             sage: len(units) == 6
@@ -4800,8 +4800,8 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
             sage: K.<a> = QuadraticField(-105)
             sage: K._S_class_group_quotient_matrix((K.ideal(11, a + 4),))
             [0 0]
-            [1 0]
             [0 1]
+            [1 0]
 
         TESTS:
 
@@ -4938,7 +4938,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
              1/13*a^2 + 7/13*a - 332/13,
              -1/13*a^2 + 6/13*a + 345/13,
              -1,
-             2/13*a^2 + 1/13*a - 755/13]
+             -2/13*a^2 - 1/13*a + 755/13]
             sage: gens[5] in (1/13*a^2 - 19/13*a - 7/13, 1/13*a^2 + 20/13*a - 7/13)
             True
             sage: gens[6] in (-1/13*a^2 + 45/13*a - 97/13, 1/13*a^2 - 45/13*a + 97/13)
@@ -6115,28 +6115,37 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
         try:
             return self._integral_basis_dict[v]
         except (AttributeError, KeyError):
-            f = self.pari_polynomial("y")
-            if v:
-                B = f.nfbasis(fa=v)
-            elif self._assume_disc_small:
-                B = f.nfbasis(1)
-            elif not important:
-                # Trial divide the discriminant with primes up to 10^6
-                m = self.pari_polynomial().poldisc().abs().factor(limit=10**6)
-                # Since we only need a *squarefree* factorization for
-                # primes with exponent 1, we need trial division up to D^(1/3)
-                # instead of D^(1/2).
-                trialdivlimit2 = pari(10**12)
-                trialdivlimit3 = pari(10**18)
-                if all(p < trialdivlimit2 or (e == 1 and p < trialdivlimit3) or p.isprime() for p, e in zip(m[0], m[1])):
-                    B = f.nfbasis(fa = m)
-                else:
-                    raise RuntimeError("Unable to factor discriminant with trial division")
+            pass
+
+        f = self.pari_polynomial("y")
+        if v:
+            # NOTE: here we make pari know about potentially big primes factors of
+            # the discriminant, see
+            # https://pari.math.u-bordeaux.fr/cgi-bin/bugreport.cgi?bug=2257
+            primelimit = pari.default("primelimit")
+            primes = [p for p in v if p > primelimit]
+            if primes:
+                pari.addprimes(primes)
+            B = f.nfbasis(fa=v)
+        elif self._assume_disc_small:
+            B = f.nfbasis(1)
+        elif not important:
+            # Trial divide the discriminant with primes up to 10^6
+            m = self.pari_polynomial().poldisc().abs().factor(limit=10**6)
+            # Since we only need a *squarefree* factorization for
+            # primes with exponent 1, we need trial division up to D^(1/3)
+            # instead of D^(1/2).
+            trialdivlimit2 = pari(10**12)
+            trialdivlimit3 = pari(10**18)
+            if all(p < trialdivlimit2 or (e == 1 and p < trialdivlimit3) or p.isprime() for p, e in zip(m[0], m[1])):
+                B = f.nfbasis(fa = m)
             else:
-                B = f.nfbasis()
+                raise RuntimeError("Unable to factor discriminant with trial division")
+        else:
+            B = f.nfbasis()
 
-            self._integral_basis_dict[v] = B
-            return B
+        self._integral_basis_dict[v] = B
+        return B
 
     def reduced_basis(self, prec=None):
         r"""
@@ -6763,7 +6772,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
             sage: A = x^4 - 10*x^3 + 20*5*x^2 - 15*5^2*x + 11*5^3
             sage: K = NumberField(A, 'a')
             sage: K.units()
-            (8/275*a^3 - 12/55*a^2 + 15/11*a - 3,)
+            (-1/275*a^3 - 4/55*a^2 + 5/11*a - 3,)
 
         For big number fields, provably computing the unit group can
         take a very long time.  In this case, one can ask for the
@@ -6774,14 +6783,14 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
             sage: K.units(proof=True)  # takes forever, not tested
             ...
             sage: K.units(proof=False)  # result not independently verified
-            (a^9 + a - 1,
-             a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2,
-             a^16 - a^15 + a^14 - a^12 + a^11 - a^10 - a^8 + a^7 - 2*a^6 + a^4 - 3*a^3 + 2*a^2 - 2*a + 1,
+            (-a^9 - a + 1,
+             -a^16 + a^15 - a^14 + a^12 - a^11 + a^10 + a^8 - a^7 + 2*a^6 - a^4 + 3*a^3 - 2*a^2 + 2*a - 1,
              2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4,
-             2*a^16 - 3*a^15 + 3*a^14 - 3*a^13 + 3*a^12 - a^11 + a^9 - 3*a^8 + 4*a^7 - 5*a^6 + 6*a^5 - 4*a^4 + 3*a^3 - 2*a^2 - 2*a + 4,
-             a^16 - a^15 - 3*a^14 - 4*a^13 - 4*a^12 - 3*a^11 - a^10 + 2*a^9 + 4*a^8 + 5*a^7 + 4*a^6 + 2*a^5 - 2*a^4 - 6*a^3 - 9*a^2 - 9*a - 7,
              a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1,
-             5*a^16 - 6*a^14 + a^13 + 7*a^12 - 2*a^11 - 7*a^10 + 4*a^9 + 7*a^8 - 6*a^7 - 7*a^6 + 8*a^5 + 6*a^4 - 11*a^3 - 5*a^2 + 13*a + 4)
+             -a^16 - a^15 - a^14 - a^13 - a^12 - a^11 - a^10 - a^9 - a^8 - a^7 - a^6 - a^5 - a^4 - a^3 - a^2 + 2,
+             -2*a^16 + 3*a^15 - 3*a^14 + 3*a^13 - 3*a^12 + a^11 - a^9 + 3*a^8 - 4*a^7 + 5*a^6 - 6*a^5 + 4*a^4 - 3*a^3 + 2*a^2 + 2*a - 4,
+             a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2,
+             -a^14 - a^13 + a^12 + 2*a^10 + a^8 - 2*a^7 - 2*a^6 + 2*a^3 - a^2 + 2*a - 2)
 
         TESTS:
 
@@ -6790,7 +6799,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
 
             sage: K.<a> = NumberField(1/2*x^2 - 1/6)
             sage: K.units()
-            (3*a - 2,)
+            (-3*a + 2,)
         """
         proof = proof_flag(proof)
 
@@ -6869,7 +6878,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
             sage: U.gens()
             (u0, u1, u2, u3, u4, u5, u6, u7, u8)
             sage: U.gens_values()  # result not independently verified
-            [-1, a^9 + a - 1, a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2, a^16 - a^15 + a^14 - a^12 + a^11 - a^10 - a^8 + a^7 - 2*a^6 + a^4 - 3*a^3 + 2*a^2 - 2*a + 1, 2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4, 2*a^16 - 3*a^15 + 3*a^14 - 3*a^13 + 3*a^12 - a^11 + a^9 - 3*a^8 + 4*a^7 - 5*a^6 + 6*a^5 - 4*a^4 + 3*a^3 - 2*a^2 - 2*a + 4, a^16 - a^15 - 3*a^14 - 4*a^13 - 4*a^12 - 3*a^11 - a^10 + 2*a^9 + 4*a^8 + 5*a^7 + 4*a^6 + 2*a^5 - 2*a^4 - 6*a^3 - 9*a^2 - 9*a - 7, a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1, 5*a^16 - 6*a^14 + a^13 + 7*a^12 - 2*a^11 - 7*a^10 + 4*a^9 + 7*a^8 - 6*a^7 - 7*a^6 + 8*a^5 + 6*a^4 - 11*a^3 - 5*a^2 + 13*a + 4]
+            [-1, -a^9 - a + 1, -a^16 + a^15 - a^14 + a^12 - a^11 + a^10 + a^8 - a^7 + 2*a^6 - a^4 + 3*a^3 - 2*a^2 + 2*a - 1, 2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4, a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1, -a^16 - a^15 - a^14 - a^13 - a^12 - a^11 - a^10 - a^9 - a^8 - a^7 - a^6 - a^5 - a^4 - a^3 - a^2 + 2, -2*a^16 + 3*a^15 - 3*a^14 + 3*a^13 - 3*a^12 + a^11 - a^9 + 3*a^8 - 4*a^7 + 5*a^6 - 6*a^5 + 4*a^4 - 3*a^3 + 2*a^2 + 2*a - 4, a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2, -a^14 - a^13 + a^12 + 2*a^10 + a^8 - 2*a^7 - 2*a^6 + 2*a^3 - a^2 + 2*a - 2]
         """
         proof = proof_flag(proof)
 
@@ -7057,7 +7066,7 @@ class NumberField_generic(WithEqualityById, number_field_base.NumberField):
 
             sage: solutions, bound = K.S_unit_solutions(S, prec=100, include_bound=True)
             sage: bound
-            6
+            7
         """
         from .S_unit_solver import solve_S_unit_equation
         return solve_S_unit_equation(self, S, prec, include_exponents, include_bound, proof)
@@ -10877,9 +10886,9 @@ class NumberField_cyclotomic(NumberField_absolute):
         EXAMPLES::
 
             sage: k5.<z> = CyclotomicField(5)
-            sage: gap('E(5)^7 + 3')
+            sage: w = libgap.eval('E(5)^7 + 3')
+            sage: w
             -3*E(5)-2*E(5)^2-3*E(5)^3-3*E(5)^4
-            sage: w = gap('E(5)^7 + 3')
             sage: z^7 + 3
             z^2 + 3
             sage: k5(w) # indirect doctest
@@ -10890,7 +10899,7 @@ class NumberField_cyclotomic(NumberField_absolute):
 
             sage: F = CyclotomicField(8)
             sage: z = F.gen()
-            sage: a = gap(z+1/z); a
+            sage: a = libgap(z+1/z); a
             E(8)-E(8)^3
             sage: F(a)
             -zeta8^3 + zeta8
@@ -10904,6 +10913,7 @@ class NumberField_cyclotomic(NumberField_absolute):
 
         It also works with the old pexpect interface to GAP::
 
+            sage: a = gap(z + 1/z)
             sage: b = gap(Matrix(F,[[z^2,1],[0,a+1]])); b
             [ [ E(4), 1 ], [ 0, 1+E(8)-E(8)^3 ] ]
             sage: b[1,2]
diff --git a/src/sage/rings/number_field/number_field_element.pyx b/src/sage/rings/number_field/number_field_element.pyx
index 29932830f3..35e2857d96 100644
--- a/src/sage/rings/number_field/number_field_element.pyx
+++ b/src/sage/rings/number_field/number_field_element.pyx
@@ -1632,7 +1632,7 @@ cdef class NumberFieldElement(FieldElement):
             sage: Q.<X> = K[]
             sage: L.<b> = NumberField(X^4 + a)
             sage: t = (-a).is_norm(L, element=True); t
-            (True, b^3 + 1)
+            (True, -b^3 - 1)
             sage: t[1].norm(K)
             -a
 
@@ -1747,11 +1747,11 @@ cdef class NumberFieldElement(FieldElement):
             sage: Q.<X> = K[]
             sage: L.<b> = NumberField(X^4 + a)
             sage: t = (-a)._rnfisnorm(L); t
-            (b^3 + 1, 1)
+            (-b^3 - 1, 1)
             sage: t[0].norm(K)
             -a
             sage: t = K(3)._rnfisnorm(L); t
-            (-b^3 - a*b^2 - a^2*b + 1, 3*a^2 - 3*a + 6)
+            (b^3 + a*b^2 + a^2*b - 1, 3*a^2 - 3*a + 6)
             sage: t[0].norm(K)*t[1]
             3
 
diff --git a/src/sage/rings/number_field/number_field_ideal.py b/src/sage/rings/number_field/number_field_ideal.py
index 01e5d47902..2478fdb009 100644
--- a/src/sage/rings/number_field/number_field_ideal.py
+++ b/src/sage/rings/number_field/number_field_ideal.py
@@ -231,7 +231,7 @@ class NumberFieldIdeal(Ideal_generic):
             sage: K.<a> = NumberField(x^2 + 3); K
             Number Field in a with defining polynomial x^2 + 3
             sage: f = K.factor(15); f
-            (Fractional ideal (-a))^2 * (Fractional ideal (5))
+            (Fractional ideal (1/2*a + 3/2))^2 * (Fractional ideal (5))
             sage: (f[0][0] < f[1][0])
             True
             sage: (f[0][0] == f[0][0])
@@ -620,7 +620,7 @@ class NumberFieldIdeal(Ideal_generic):
 
             sage: K.<z> = CyclotomicField(7)
             sage: I = K.factor(11)[0][0]; I
-            Fractional ideal (-2*z^4 - 2*z^2 - 2*z + 1)
+            Fractional ideal (-3*z^4 - 2*z^3 - 2*z^2 - 2)
             sage: A = I.free_module()
             sage: A              # warning -- choice of basis can be somewhat random
             Free module of degree 6 and rank 6 over Integer Ring
@@ -780,7 +780,6 @@ class NumberFieldIdeal(Ideal_generic):
             sage: P = EllipticCurve(L, '57a1').lift_x(z_x) * 3
             sage: ideal = L.fractional_ideal(P[0], P[1])
             sage: ideal.is_principal(proof=False)
-              ***   Warning: precision too low for generators, not given.
             True
             sage: len(ideal.gens_reduced(proof=False))
             1
@@ -789,7 +788,7 @@ class NumberFieldIdeal(Ideal_generic):
             self._is_principal = True
             self._reduced_generators = self.gens()
             return self._reduced_generators
-        self._cache_bnfisprincipal(proof=proof, gens_needed=True)
+        self._cache_bnfisprincipal(proof=proof, gens=True)
         return self._reduced_generators
 
     def gens_two(self):
@@ -828,10 +827,13 @@ class NumberFieldIdeal(Ideal_generic):
         try:
             return self.__two_generators
         except AttributeError:
-            if self.is_zero():
-                self.__two_generators = (0,0)
-                return self.__two_generators
-            K = self.number_field()
+            pass
+
+        K = self.number_field()
+
+        if self.is_zero():
+            self.__two_generators = (K.zero(), K.zero())
+        else:
             HNF = self.pari_hnf()
             # Check whether the ideal is generated by an integer, i.e.
             # whether HNF is a multiple of the identity matrix
@@ -840,7 +842,8 @@ class NumberFieldIdeal(Ideal_generic):
             else:
                 a, alpha = K.pari_nf().idealtwoelt(HNF)
             self.__two_generators = (K(a), K(alpha))
-            return self.__two_generators
+
+        return self.__two_generators
 
     def integral_basis(self):
         r"""
@@ -1030,7 +1033,7 @@ class NumberFieldIdeal(Ideal_generic):
            raise ValueError("%s is not a prime ideal" % self)
         return self._pari_prime
 
-    def _cache_bnfisprincipal(self, proof=None, gens_needed=False):
+    def _cache_bnfisprincipal(self, proof=None, gens=False):
         r"""
         This function is essentially the implementation of
         :meth:`is_principal`, :meth:`gens_reduced` and
@@ -1042,9 +1045,8 @@ class NumberFieldIdeal(Ideal_generic):
 
         - ``proof`` -- proof flag.  If ``proof=False``, assume GRH.
 
-        - ``gens_needed`` -- (default: True) if True, insist on computing
-          the reduced generators of the ideal.  With ``gens=False``, they
-          may or may not be computed (depending on how big the ideal is).
+        - ``gens`` -- (default: False) if True, also computes the reduced
+          generators of the ideal.
 
         OUTPUT:
 
@@ -1052,6 +1054,15 @@ class NumberFieldIdeal(Ideal_generic):
         ``_ideal_class_log`` (see :meth:`ideal_class_log`),
         ``_is_principal`` (see :meth:`is_principal`) and
         ``_reduced_generators``.
+
+        TESTS:
+
+        Check that no warnings are triggered from PARI/GP (see :trac:`30801`)::
+
+            sage: K.<a> = NumberField(x^2 - x + 112941801)
+            sage: I = K.ideal((112941823, a + 49942513))
+            sage: I.is_principal()
+            False
         """
         # Since pari_bnf() is cached, this call to pari_bnf() should not
         # influence the run-time much.  Also, this simplifies the handling
@@ -1063,29 +1074,33 @@ class NumberFieldIdeal(Ideal_generic):
 
         # If we already have _reduced_generators, no need to compute them again
         if hasattr(self, "_reduced_generators"):
-            gens_needed = False
+            gens = False
 
         # Is there something to do?
-        if hasattr(self, "_ideal_class_log") and not gens_needed:
+        if hasattr(self, "_ideal_class_log") and not gens:
             self._is_principal = not any(self._ideal_class_log)
             return
 
-        # Call bnfisprincipal().
-        # If gens_needed, use flag=3 which will insist on computing
-        # the generator.  Otherwise, use flag=1, where the generator
-        # may or may not be computed.
-        v = bnf.bnfisprincipal(self.pari_hnf(), 3 if gens_needed else 1)
-        self._ideal_class_log = list(v[0])
-        self._is_principal = not any(self._ideal_class_log)
-
-        if self._is_principal:
-            # Cache reduced generator if it was computed
-            if v[1]:
-                g = self.number_field()(v[1])
-                self._reduced_generators = (g,)
+        if not gens:
+            v = bnf.bnfisprincipal(self.pari_hnf(), 0)
+            self._ideal_class_log = list(v)
+            self._is_principal = not any(self._ideal_class_log)
         else:
-            # Non-principal ideal, compute two generators if asked for
-            if gens_needed:
+            # TODO: this is a bit of a waste. We ask bnfisprincipal to compute the compact form and then
+            # convert this compact form back into an expanded form.
+            # (though calling with 3 instead of 5 most likely triggers an error with memory allocation failure)
+            v = bnf.bnfisprincipal(self.pari_hnf(), 5)
+            e = v[0]
+            t = v[1]
+            t = bnf.nfbasistoalg(bnf.nffactorback(t))
+            self._ideal_class_log = list(e)
+            self._is_principal = not any(self._ideal_class_log)
+
+            if self._is_principal:
+                g = self.number_field()(t)
+                self._reduced_generators = (g,)
+            elif gens:
+                # Non-principal ideal
                 self._reduced_generators = self.gens_two()
 
     def is_principal(self, proof=None):
@@ -3118,7 +3133,7 @@ class NumberFieldFractionalIdeal(MultiplicativeGroupElement, NumberFieldIdeal):
             sage: K.<a> = NumberField(x^5 + 2); K
             Number Field in a with defining polynomial x^5 + 2
             sage: f = K.factor(19); f
-            (Fractional ideal (a^2 + a - 3)) * (Fractional ideal (-2*a^4 - a^2 + 2*a - 1)) * (Fractional ideal (a^2 + a - 1))
+            (Fractional ideal (a^2 + a - 3)) * (Fractional ideal (2*a^4 + a^2 - 2*a + 1)) * (Fractional ideal (a^2 + a - 1))
             sage: [i.residue_class_degree() for i, _ in f]
             [2, 2, 1]
         """
diff --git a/src/sage/rings/number_field/number_field_ideal_rel.py b/src/sage/rings/number_field/number_field_ideal_rel.py
index 37c20150ad..078682fa1f 100644
--- a/src/sage/rings/number_field/number_field_ideal_rel.py
+++ b/src/sage/rings/number_field/number_field_ideal_rel.py
@@ -18,7 +18,7 @@ EXAMPLES::
     sage: G = [from_A(z) for z in I.gens()]; G
     [7, -2*b*a - 1]
     sage: K.fractional_ideal(G)
-    Fractional ideal (2*b*a + 1)
+    Fractional ideal ((1/2*b + 2)*a - 1/2*b + 2)
     sage: K.fractional_ideal(G).absolute_norm().factor()
     7^2
 """
diff --git a/src/sage/rings/number_field/number_field_rel.py b/src/sage/rings/number_field/number_field_rel.py
index e103bd8e59..3097a98002 100644
--- a/src/sage/rings/number_field/number_field_rel.py
+++ b/src/sage/rings/number_field/number_field_rel.py
@@ -396,18 +396,18 @@ class NumberField_relative(NumberField_generic):
             sage: K.<c> = F.extension(Y^2 - (1 + a)*(a + b)*a*b)
             sage: K.subfields(2)
             [
-            (Number Field in c0 with defining polynomial x^2 - 24*x + 72, Ring morphism:
-              From: Number Field in c0 with defining polynomial x^2 - 24*x + 72
+            (Number Field in c0 with defining polynomial x^2 - 24*x + 96, Ring morphism:
+              From: Number Field in c0 with defining polynomial x^2 - 24*x + 96
               To:   Number Field in c with defining polynomial Y^2 + (-2*b - 3)*a - 2*b - 6 over its base field
-              Defn: c0 |--> -6*a + 12, None),
+              Defn: c0 |--> -4*b + 12, None),
             (Number Field in c1 with defining polynomial x^2 - 24*x + 120, Ring morphism:
               From: Number Field in c1 with defining polynomial x^2 - 24*x + 120
               To:   Number Field in c with defining polynomial Y^2 + (-2*b - 3)*a - 2*b - 6 over its base field
               Defn: c1 |--> 2*b*a + 12, None),
-            (Number Field in c2 with defining polynomial x^2 - 24*x + 96, Ring morphism:
-              From: Number Field in c2 with defining polynomial x^2 - 24*x + 96
+            (Number Field in c2 with defining polynomial x^2 - 24*x + 72, Ring morphism:
+              From: Number Field in c2 with defining polynomial x^2 - 24*x + 72
               To:   Number Field in c with defining polynomial Y^2 + (-2*b - 3)*a - 2*b - 6 over its base field
-              Defn: c2 |--> -4*b + 12, None)
+              Defn: c2 |--> -6*a + 12, None)
             ]
             sage: K.subfields(8, 'w')
             [
diff --git a/src/sage/rings/number_field/order.py b/src/sage/rings/number_field/order.py
index b5cdeb2a96..be1548f7a2 100644
--- a/src/sage/rings/number_field/order.py
+++ b/src/sage/rings/number_field/order.py
@@ -2180,7 +2180,7 @@ def EisensteinIntegers(names="omega"):
         sage: R
         Eisenstein Integers in Number Field in omega with defining polynomial x^2 + x + 1 with omega = -0.50000000000000000? + 0.866025403784439?*I
         sage: factor(3 + omega)
-        (omega) * (-3*omega - 2)
+        (-1) * (-omega - 3)
         sage: CC(omega)
         -0.500000000000000 + 0.866025403784439*I
         sage: omega.minpoly()
diff --git a/src/sage/rings/number_field/unit_group.py b/src/sage/rings/number_field/unit_group.py
index d0508258a0..6dd6b68cb3 100644
--- a/src/sage/rings/number_field/unit_group.py
+++ b/src/sage/rings/number_field/unit_group.py
@@ -15,12 +15,12 @@ The first generator is a primitive root of unity in the field::
     sage: UK.gens_values()  # random
     [-1/12*a^3 + 1/6*a, 1/24*a^3 + 1/4*a^2 - 1/12*a - 1]
     sage: UK.gen(0).value()
-    -1/12*a^3 + 1/6*a
+    1/12*a^3 - 1/6*a
 
     sage: UK.gen(0)
     u0
     sage: UK.gen(0) + K.one()   # coerce abstract generator into number field
-    -1/12*a^3 + 1/6*a + 1
+    1/12*a^3 - 1/6*a + 1
 
     sage: [u.multiplicative_order() for u in UK.gens()]
     [4, +Infinity]
@@ -37,18 +37,18 @@ as elements of an abstract multiplicative group::
     sage: UK(-1)
     u0^2
     sage: [UK(u) for u in (x^4-1).roots(K, multiplicities=False)]
-    [1, u0^2, u0^3, u0]
+    [1, u0^2, u0, u0^3]
 
     sage: UK.fundamental_units() # random
     [1/24*a^3 + 1/4*a^2 - 1/12*a - 1]
     sage: torsion_gen = UK.torsion_generator();  torsion_gen
     u0
     sage: torsion_gen.value()
-    -1/12*a^3 + 1/6*a
+    1/12*a^3 - 1/6*a
     sage: UK.zeta_order()
     4
     sage: UK.roots_of_unity()
-    [-1/12*a^3 + 1/6*a, -1, 1/12*a^3 - 1/6*a, 1]
+    [1/12*a^3 - 1/6*a, -1, -1/12*a^3 + 1/6*a, 1]
 
 Exp and log functions provide maps between units as field elements and exponent
 vectors with respect to the generators::
@@ -82,7 +82,7 @@ S-unit groups may be constructed, where S is a set of primes::
     sage: SUK.rank()
     4
     sage: SUK.gens_values()
-    [-1, a^2 + 1, a^5 + a^4 - a^2 - a - 1, a + 1, -a + 1]
+    [-1, a^2 + 1, -a^5 - a^4 + a^2 + a + 1, a + 1, a - 1]
     sage: u = 9*prod(SUK.gens_values()); u
     -18*a^5 - 18*a^4 - 18*a^3 - 9*a^2 + 9*a + 27
     sage: SUK.log(u)
@@ -100,29 +100,29 @@ A relative number field example::
     sage: UL.zeta_order()
     24
     sage: UL.roots_of_unity()
-    [-b*a - b,
-     b^2*a,
-     b^3,
-     a + 1,
-     -b*a,
-     -b^2,
-     b^3*a + b^3,
-     a,
-     b,
+    [-b*a,
      -b^2*a - b^2,
-     b^3*a,
-     -1,
-     b*a + b,
-     -b^2*a,
      -b^3,
-     -a - 1,
-     b*a,
-     b^2,
-     -b^3*a - b^3,
      -a,
+     -b*a - b,
+     -b^2,
+     b^3*a,
+     -a - 1,
      -b,
+     b^2*a,
+     b^3*a + b^3,
+     -1,
+     b*a,
      b^2*a + b^2,
+     b^3,
+     a,
+     b*a + b,
+     b^2,
      -b^3*a,
+     a + 1,
+     b,
+     -b^2*a,
+     -b^3*a - b^3,
      1]
 
 A relative extension example, which worked thanks to the code review by F.W.Clarke::
@@ -199,7 +199,7 @@ class UnitGroup(AbelianGroupWithValues_class):
         sage: UK.gen(5)
         u5
         sage: UK.gen(5).value()
-        z^7 + z
+        -z^7 - z
 
     An S-unit group::
 
@@ -216,7 +216,7 @@ class UnitGroup(AbelianGroupWithValues_class):
         sage: SUK.zeta_order()
         26
         sage: SUK.log(21*z)
-        (12, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
+        (25, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
     """
     # This structure is not a parent in the usual sense. The
     # "elements" are NumberFieldElement_absolute. Instead, they should
@@ -250,7 +250,7 @@ class UnitGroup(AbelianGroupWithValues_class):
             sage: UK.gens()
             (u0, u1)
             sage: UK.gens_values()
-            [-1, 6*a - 37]
+            [-1, -6*a + 37]
 
             sage: K.<a> = QuadraticField(-3)
             sage: UK = K.unit_group(); UK
@@ -258,7 +258,7 @@ class UnitGroup(AbelianGroupWithValues_class):
             sage: UK.gens()
             (u,)
             sage: UK.gens_values()
-            [1/2*a + 1/2]
+            [-1/2*a + 1/2]
 
             sage: K.<z> = CyclotomicField(13)
             sage: UK = K.unit_group(); UK
@@ -329,28 +329,25 @@ class UnitGroup(AbelianGroupWithValues_class):
 
         # compute the additional S-unit generators:
         if S:
-            self.__S_unit_data = pK.bnfsunit(pS)
-            su = [K(u, check=False) for u in self.__S_unit_data[0]]
+            self.__S_unit_data = pK.bnfunits(pS)
         else:
-            su = []
-        self.__nsu = len(su)
+            self.__S_unit_data = pK.bnfunits()
+        # TODO: converting the factored matrix representation of bnfunits into polynomial
+        # form is a *big* waste of time
+        su_fu_tu = [pK.nfbasistoalg(pK.nffactorback(z)) for z in self.__S_unit_data[0]]
+
+        self.__nfu = len(pK.bnf_get_fu())           # number of fundamental units
+        self.__nsu = len(su_fu_tu) - self.__nfu - 1 # number of S-units
+        self.__ntu = pK.bnf_get_tu()[0]             # order of torsion
         self.__rank = self.__nfu + self.__nsu
 
-        # compute a torsion generator and pick the 'simplest' one:
-        n, z = pK[7][3] # number of roots of unity and bnf.tu as in pari documentation
-        n = ZZ(n)
-        self.__ntu = n
-        z = K(z, check=False)
-
-        # If we replaced z by another torsion generator we would need
-        # to allow for this in the dlog function!  So we do not.
+        # Move the torsion unit first, then fundamental units then S-units
+        gens = [K(u, check=False) for u in su_fu_tu]
+        gens = [gens[-1]] + gens[self.__nsu:-1] + gens[:self.__nsu]
 
-        # Store the actual generators (torsion first):
-        gens = [z] + fu + su
-        values = Sequence(gens, immutable=True, universe=self, check=False)
         # Construct the abstract group:
-        gens_orders = tuple([ZZ(n)]+[ZZ(0)]*(self.__rank))
-        AbelianGroupWithValues_class.__init__(self, gens_orders, 'u', values, number_field)
+        gens_orders = tuple([ZZ(self.__ntu)]+[ZZ(0)]*(self.__rank))
+        AbelianGroupWithValues_class.__init__(self, gens_orders, 'u', gens, number_field)
 
     def _element_constructor_(self, u):
         """
@@ -375,7 +372,7 @@ class UnitGroup(AbelianGroupWithValues_class):
             sage: UK.gens()
             (u0, u1)
             sage: UK.gens_values()
-            [-1, 6*a - 37]
+            [-1, -6*a + 37]
             sage: UK.ngens()
             2
             sage: [UK(u) for u in UK.gens()]
@@ -394,8 +391,8 @@ class UnitGroup(AbelianGroupWithValues_class):
         except TypeError:
             raise ValueError("%s is not an element of %s"%(u,K))
         if self.__S:
-            m = pK.bnfissunit(self.__S_unit_data, pari(u)).mattranspose()
-            if m.ncols()==0:
+            m = pK.bnfisunit(pari(u), self.__S_unit_data).mattranspose()
+            if m.ncols() == 0:
                 raise ValueError("%s is not an S-unit"%u)
         else:
             if not u.is_integral() or u.norm().abs() != 1:
@@ -405,9 +402,8 @@ class UnitGroup(AbelianGroupWithValues_class):
         # convert column matrix to a list:
         m = [ZZ(m[0,i].sage()) for i in range(m.ncols())]
 
-        # NB pari puts the torsion after the fundamental units, before
-        # the extra S-units but we have the torsion first:
-        m = [m[self.__nfu]] + m[:self.__nfu] + m[self.__nfu+1:]
+        # NOTE: pari ordering for the units is (S-units, fundamental units, torsion unit)
+        m = [m[-1]] + m[self.__nsu:-1] + m[:self.__nsu]
 
         return self.element_class(self, m)
 
@@ -527,9 +523,9 @@ class UnitGroup(AbelianGroupWithValues_class):
             sage: U.zeta(2, all=True)
             [-1]
             sage: U.zeta(3)
-            1/2*z - 1/2
+            -1/2*z - 1/2
             sage: U.zeta(3, all=True)
-            [1/2*z - 1/2, -1/2*z - 1/2]
+            [-1/2*z - 1/2, 1/2*z - 1/2]
             sage: U.zeta(4)
             Traceback (most recent call last):
             ...
@@ -645,7 +641,7 @@ class UnitGroup(AbelianGroupWithValues_class):
            sage: SUK = UnitGroup(K,S=2)
            sage: v = (3,1,4,1,5,9,2)
            sage: u = SUK.exp(v); u
-           -8732*z^11 + 15496*z^10 + 51840*z^9 + 68804*z^8 + 51840*z^7 + 15496*z^6 - 8732*z^5 + 34216*z^3 + 64312*z^2 + 64312*z + 34216
+           8732*z^11 - 15496*z^10 - 51840*z^9 - 68804*z^8 - 51840*z^7 - 15496*z^6 + 8732*z^5 - 34216*z^3 - 64312*z^2 - 64312*z - 34216
            sage: SUK.log(u)
            (3, 1, 4, 1, 5, 9, 2)
            sage: SUK.log(u) == v
@@ -692,7 +688,7 @@ class UnitGroup(AbelianGroupWithValues_class):
            sage: SUK = UnitGroup(K,S=2)
            sage: v = (3,1,4,1,5,9,2)
            sage: u = SUK.exp(v); u
-           -8732*z^11 + 15496*z^10 + 51840*z^9 + 68804*z^8 + 51840*z^7 + 15496*z^6 - 8732*z^5 + 34216*z^3 + 64312*z^2 + 64312*z + 34216
+           8732*z^11 - 15496*z^10 - 51840*z^9 - 68804*z^8 - 51840*z^7 - 15496*z^6 + 8732*z^5 - 34216*z^3 - 64312*z^2 - 64312*z - 34216
            sage: SUK.log(u)
            (3, 1, 4, 1, 5, 9, 2)
            sage: SUK.log(u) == v
diff --git a/src/sage/rings/polynomial/polynomial_element.pyx b/src/sage/rings/polynomial/polynomial_element.pyx
index 570c148e72..17f3ec8da9 100644
--- a/src/sage/rings/polynomial/polynomial_element.pyx
+++ b/src/sage/rings/polynomial/polynomial_element.pyx
@@ -7619,7 +7619,7 @@ cdef class Polynomial(CommutativeAlgebraElement):
             [(-3.5074662110434039?e451, 1)]
             sage: p = bigc*x + 1
             sage: p.roots(ring=RR)
-            [(0.000000000000000, 1)]
+            [(-2.85106096489671e-452, 1)]
             sage: p.roots(ring=AA)
             [(-2.8510609648967059?e-452, 1)]
             sage: p.roots(ring=QQbar)
diff --git a/src/sage/rings/polynomial/polynomial_quotient_ring.py b/src/sage/rings/polynomial/polynomial_quotient_ring.py
index 699e0ac285..046180445f 100644
--- a/src/sage/rings/polynomial/polynomial_quotient_ring.py
+++ b/src/sage/rings/polynomial/polynomial_quotient_ring.py
@@ -1307,7 +1307,7 @@ class PolynomialQuotientRing_generic(CommutativeRing):
         `x^2 + 31` from 12 to 2, i.e. we lose a generator of order 6 (this was
         fixed in :trac:`14489`)::
 
-            sage: S.S_class_group([K.ideal(a)])
+            sage: S.S_class_group([K.ideal(a)])  # representation varies, not tested
             [((1/4*xbar^2 + 31/4, (-1/8*a + 1/8)*xbar^2 - 31/8*a + 31/8, 1/16*xbar^3 + 1/16*xbar^2 + 31/16*xbar + 31/16, -1/16*a*xbar^3 + (1/16*a + 1/8)*xbar^2 - 31/16*a*xbar + 31/16*a + 31/8), 6), ((-1/4*xbar^2 - 23/4, (1/8*a - 1/8)*xbar^2 + 23/8*a - 23/8, -1/16*xbar^3 - 1/16*xbar^2 - 23/16*xbar - 23/16, 1/16*a*xbar^3 + (-1/16*a - 1/8)*xbar^2 + 23/16*a*xbar - 23/16*a - 23/8), 2)]
 
         Note that all the returned values live where we expect them to::
diff --git a/src/sage/sandpiles/sandpile.py b/src/sage/sandpiles/sandpile.py
index ad1cc56276..ce4e7fdc9b 100644
--- a/src/sage/sandpiles/sandpile.py
+++ b/src/sage/sandpiles/sandpile.py
@@ -1494,12 +1494,12 @@ class Sandpile(DiGraph):
 
             sage: s = sandpiles.Cycle(5)
             sage: s.group_gens()
-            [{1: 1, 2: 1, 3: 1, 4: 0}]
+            [{1: 0, 2: 1, 3: 1, 4: 1}]
             sage: s.group_gens()[0].order()
             5
             sage: s = sandpiles.Complete(5)
             sage: s.group_gens(False)
-            [[2, 2, 3, 2], [2, 3, 2, 2], [3, 2, 2, 2]]
+            [[2, 3, 2, 2], [2, 2, 3, 2], [2, 2, 2, 3]]
             sage: [i.order() for i in s.group_gens()]
             [5, 5, 5]
             sage: s.invariant_factors()
@@ -2817,7 +2817,7 @@ class Sandpile(DiGraph):
 
             sage: S = sandpiles.Complete(4)
             sage: S.points()
-            [[1, I, -I], [I, 1, -I]]
+            [[-I, I, 1], [-I, 1, I]]
         """
         return self._points
 
@@ -5015,7 +5015,7 @@ class SandpileDivisor(dict):
             sage: D.is_linearly_equivalent([0,1,1])
             True
             sage: D.is_linearly_equivalent([0,1,1],True)
-            (1, 0, 0)
+            (0, -1, -1)
             sage: v = vector(D.is_linearly_equivalent([0,1,1],True))
             sage: vector(D.values()) - s.laplacian()*v
             (0, 1, 1)
@@ -6646,8 +6646,8 @@ def wilmes_algorithm(M):
 
         sage: P = matrix([[2,3,-7,-3],[5,2,-5,5],[8,2,5,4],[-5,-9,6,6]])
         sage: wilmes_algorithm(P)
-        [ 1642   -13 -1627    -1]
-        [   -1  1980 -1582  -397]
+        [ 3279   -79 -1599 -1600]
+        [   -1  1539  -136 -1402]
         [    0    -1  1650 -1649]
         [    0     0 -1658  1658]
 
diff --git a/src/sage/schemes/elliptic_curves/ell_finite_field.py b/src/sage/schemes/elliptic_curves/ell_finite_field.py
index 2aca9491af..76b111b423 100644
--- a/src/sage/schemes/elliptic_curves/ell_finite_field.py
+++ b/src/sage/schemes/elliptic_curves/ell_finite_field.py
@@ -785,11 +785,13 @@ class EllipticCurve_finite_field(EllipticCurve_field, HyperellipticCurve_finite_
             sage: len(E.gens())
             2
             sage: E.cardinality()
-            867361737988403547207212930746733987710588
-            sage: E.gens()[0].order()
-            433680868994201773603606465373366993855294
-            sage: E.gens()[1].order()
-            433680868994201773603606465373366993855294
+            867361737988403547206134229616487867594472
+            sage: a = E.gens()[0].order(); a # random
+            433680868994201773603067114808243933797236
+            sage: b = E.gens()[1].order(); b # random
+            30977204928157269543076222486303138128374
+            sage: lcm(a,b)
+            433680868994201773603067114808243933797236
         """
         G = self.__pari__().ellgroup(flag=1)
         return tuple(self.point(list(pt)) for pt in G[2])
diff --git a/src/sage/schemes/elliptic_curves/ell_generic.py b/src/sage/schemes/elliptic_curves/ell_generic.py
index 7b02e8f663..a1a48d2397 100644
--- a/src/sage/schemes/elliptic_curves/ell_generic.py
+++ b/src/sage/schemes/elliptic_curves/ell_generic.py
@@ -527,7 +527,7 @@ class EllipticCurve_generic(WithEqualityById, plane_curve.ProjectivePlaneCurve):
             sage: E = EllipticCurve([0,0,0,-49,0])
             sage: T = E.torsion_subgroup()
             sage: [E(t) for t in T]
-            [(0 : 1 : 0), (-7 : 0 : 1), (0 : 0 : 1), (7 : 0 : 1)]
+            [(0 : 1 : 0), (0 : 0 : 1), (-7 : 0 : 1), (7 : 0 : 1)]
 
         ::
 
@@ -2951,8 +2951,8 @@ class EllipticCurve_generic(WithEqualityById, plane_curve.ProjectivePlaneCurve):
             Mod(-928, y^2 - 2), Mod(3456/29, y^2 - 2), Vecsmall([5]),
             [[y^2 - 2, [2, 0], 8, 1, [[1, -1.41421356237310;
             1, 1.41421356237310], [1, -1.41421356237310; 1, 1.41421356237310],
-            [1, -1; 1, 1], [2, 0; 0, 4], [4, 0; 0, 2], [2, 0; 0, 1],
-            [2, [0, 2; 1, 0]], []], [-1.41421356237310, 1.41421356237310],
+            [16, -23; 16, 23], [2, 0; 0, 4], [4, 0; 0, 2], [2, 0; 0, 1],
+            [2, [0, 2; 1, 0]], [2]], [-1.41421356237310, 1.41421356237310],
             [1, y], [1, 0; 0, 1], [1, 0, 0, 2; 0, 1, 1, 0]]], [0, 0, 0, 0, 0]]
 
         PARI no longer requires that the `j`-invariant has negative `p`-adic valuation::
diff --git a/src/sage/schemes/elliptic_curves/ell_number_field.py b/src/sage/schemes/elliptic_curves/ell_number_field.py
index 29316bebeb..ccfa33915a 100644
--- a/src/sage/schemes/elliptic_curves/ell_number_field.py
+++ b/src/sage/schemes/elliptic_curves/ell_number_field.py
@@ -214,9 +214,9 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: E == loads(dumps(E))
             True
             sage: E.simon_two_descent()
-            (2, 2, [(0 : 0 : 1), (1/8*a + 5/8 : -3/16*a - 7/16 : 1)])
-            sage: E.simon_two_descent(lim1=3, lim3=20, limtriv=5, maxprob=7, limbigprime=10)
-            (2, 2, [(-1 : 0 : 1), (-1/8*a + 5/8 : -3/16*a - 9/16 : 1)])
+            (2, 2, [(0 : 0 : 1)])
+            sage: E.simon_two_descent(lim1=5, lim3=5, limtriv=10, maxprob=7, limbigprime=10)
+            (2, 2, [(-1 : 0 : 1), (-2 : -1/2*a - 1/2 : 1)])
 
         ::
 
@@ -238,35 +238,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
             K = bnfinit(y^2 + 7);
             a = Mod(y,K.pol);
             bnfellrank(K, [0, 0, 0, 1, a], [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)]]);
-             elliptic curve: Y^2 = x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)
-              A = Mod(0, y^2 + 7)
-              B = Mod(1, y^2 + 7)
-              C = Mod(y, y^2 + 7)
-            <BLANKLINE>
-              Computing L(S,2)
-              L(S,2) = [Mod(Mod(-1/2*y + 1/2, y^2 + 7)*x^2 + Mod(-1/2*y - 1/2, y^2 + 7)*x + Mod(-y - 1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(-x^2 + Mod(-1/2*y - 1/2, y^2 + 7)*x + 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(-1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(x^2 + 2, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(x + Mod(1/2*y + 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(x + Mod(1/2*y - 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
-            <BLANKLINE>
-              Computing the Selmer group
-              #LS2gen = 2
-               LS2gen = [Mod(Mod(-1/2*y + 1/2, y^2 + 7)*x^2 + Mod(-1/2*y - 1/2, y^2 + 7)*x + Mod(-y - 1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(x^2 + Mod(1/2*y + 1/2, y^2 + 7)*x - 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
-              Search for trivial points on the curve
-             Trivial points on the curve = [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)], [1, 1, 0], [Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7), 1]]
-              zc = Mod(Mod(-1/2*y + 1/2, y^2 + 7)*x^2 + Mod(-1/2*y - 1/2, y^2 + 7)*x + Mod(-y - 1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
-              Hilbert symbol (Mod(1, y^2 + 7),Mod(-2*y + 2, y^2 + 7)) =
-              sol of quadratic equation = [1, 1, 0]~
-              zc*z1^2 = Mod(4*x + Mod(-2*y + 6, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
-              quartic: (-1)*Y^2 = x^4 + (3*y - 9)*x^2 + (-8*y + 16)*x + (9/2*y - 11/2)
-              reduced: Y^2 = -x^4 + (-3*y + 9)*x^2 + (-8*y + 16)*x + (-9/2*y + 11/2)
-              not ELS at [2, [0, 1]~, 1, 1, [1, -2; 1, 0]]
-              zc = Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y + 1/2, y^2 + 7)*x + Mod(-1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
-              comes from the trivial point [Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)]
-              m1 = 1
-              m2 = 1
-            #S(E/K)[2]    = 2
-            #E(K)/2E(K)   = 2
-            #III(E/K)[2]  = 1
-            rank(E/K)     = 1
-             listpoints = [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)]]
+            ...
             v = [1, 1, [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)]]]
             sage: v
             (1, 1, [(1/2*a + 3/2 : -a - 2 : 1)])
@@ -298,8 +270,8 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: E.simon_two_descent()  # long time (4s on sage.math, 2013)
             (3,
              3,
-             [(0 : 0 : 1),
-              (-1/2*zeta43_0^2 - 1/2*zeta43_0 + 7 : -3/2*zeta43_0^2 - 5/2*zeta43_0 + 18 : 1)...)
+             [(5/8*zeta43_0^2 + 17/8*zeta43_0 - 9/4 : -27/16*zeta43_0^2 - 103/16*zeta43_0 + 39/8 : 1),
+              (0 : 0 : 1)])
         """
         verbose = int(verbose)
         if known_points is None:
@@ -2228,29 +2200,29 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: EK = E.base_extend(K)
             sage: EK.torsion_points()  # long time (1s on sage.math, 2014)
             [(0 : 1 : 0),
-             (16 : 60 : 1),
-             (5 : 5 : 1),
-             (5 : -6 : 1),
-             (16 : -61 : 1),
              (t : 1/11*t^3 + 6/11*t^2 + 19/11*t + 48/11 : 1),
-             (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : 6/55*t^3 + 3/55*t^2 + 25/11*t + 156/55 : 1),
-             (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : -7/121*t^3 + 24/121*t^2 + 197/121*t + 16/121 : 1),
-             (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : -49/121*t^3 - 129/121*t^2 - 315/121*t - 207/121 : 1),
-             (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : 32/121*t^3 + 60/121*t^2 - 261/121*t - 807/121 : 1),
              (1/11*t^3 - 5/11*t^2 + 19/11*t - 40/11 : -6/11*t^3 - 3/11*t^2 - 26/11*t - 321/11 : 1),
-             (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : 16/121*t^3 - 69/121*t^2 + 293/121*t - 46/121 : 1),
-             (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : 7/55*t^3 - 24/55*t^2 + 9/11*t + 17/55 : 1),
-             (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : 34/121*t^3 - 27/121*t^2 + 305/121*t + 708/121 : 1),
-             (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : 15/121*t^3 + 156/121*t^2 - 232/121*t + 2766/121 : 1),
              (1/11*t^3 - 5/11*t^2 + 19/11*t - 40/11 : 6/11*t^3 + 3/11*t^2 + 26/11*t + 310/11 : 1),
-             (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : -15/121*t^3 - 156/121*t^2 + 232/121*t - 2887/121 : 1),
-             (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : -34/121*t^3 + 27/121*t^2 - 305/121*t - 829/121 : 1),
-             (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : -7/55*t^3 + 24/55*t^2 - 9/11*t - 72/55 : 1),
-             (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : -16/121*t^3 + 69/121*t^2 - 293/121*t - 75/121 : 1),
              (t : -1/11*t^3 - 6/11*t^2 - 19/11*t - 59/11 : 1),
+             (16 : 60 : 1),
+             (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : 6/55*t^3 + 3/55*t^2 + 25/11*t + 156/55 : 1),
+             (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : 16/121*t^3 - 69/121*t^2 + 293/121*t - 46/121 : 1),
+             (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : -15/121*t^3 - 156/121*t^2 + 232/121*t - 2887/121 : 1),
              (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : -32/121*t^3 - 60/121*t^2 + 261/121*t + 686/121 : 1),
+             (5 : 5 : 1),
+             (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : -7/121*t^3 + 24/121*t^2 + 197/121*t + 16/121 : 1),
+             (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : 7/55*t^3 - 24/55*t^2 + 9/11*t + 17/55 : 1),
+             (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : -34/121*t^3 + 27/121*t^2 - 305/121*t - 829/121 : 1),
              (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : 49/121*t^3 + 129/121*t^2 + 315/121*t + 86/121 : 1),
+             (5 : -6 : 1),
+             (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : -49/121*t^3 - 129/121*t^2 - 315/121*t - 207/121 : 1),
+             (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : 34/121*t^3 - 27/121*t^2 + 305/121*t + 708/121 : 1),
+             (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : -7/55*t^3 + 24/55*t^2 - 9/11*t - 72/55 : 1),
              (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : 7/121*t^3 - 24/121*t^2 - 197/121*t - 137/121 : 1),
+             (16 : -61 : 1),
+             (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : 32/121*t^3 + 60/121*t^2 - 261/121*t - 807/121 : 1),
+             (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : 15/121*t^3 + 156/121*t^2 - 232/121*t + 2766/121 : 1),
+             (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : -16/121*t^3 + 69/121*t^2 - 293/121*t - 75/121 : 1),
              (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : -6/55*t^3 - 3/55*t^2 - 25/11*t - 211/55 : 1)]
 
         ::
diff --git a/src/sage/schemes/elliptic_curves/ell_rational_field.py b/src/sage/schemes/elliptic_curves/ell_rational_field.py
index eea4c88330..31db08b9fa 100644
--- a/src/sage/schemes/elliptic_curves/ell_rational_field.py
+++ b/src/sage/schemes/elliptic_curves/ell_rational_field.py
@@ -4082,7 +4082,7 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
             sage: G.1
             (282 : 0 : 1)
             sage: list(G)
-            [(0 : 1 : 0), (147 : 12960 : 1), (2307 : 97200 : 1), (-933 : 29160 : 1), (1011 : 0 : 1), (-933 : -29160 : 1), (2307 : -97200 : 1), (147 : -12960 : 1), (282 : 0 : 1), (8787 : 816480 : 1), (-285 : 27216 : 1), (1227 : 22680 : 1), (-1293 : 0 : 1), (1227 : -22680 : 1), (-285 : -27216 : 1), (8787 : -816480 : 1)]
+            [(0 : 1 : 0), (147 : -12960 : 1), (2307 : -97200 : 1), (-933 : -29160 : 1), (1011 : 0 : 1), (-933 : 29160 : 1), (2307 : 97200 : 1), (147 : 12960 : 1), (-1293 : 0 : 1), (1227 : 22680 : 1), (-285 : 27216 : 1), (8787 : 816480 : 1), (282 : 0 : 1), (8787 : -816480 : 1), (-285 : -27216 : 1), (1227 : -22680 : 1)]
         """
         try:
             G = self.__torsion_subgroup
@@ -5405,10 +5405,10 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
         EXAMPLES::
 
             sage: E = EllipticCurve('37a1')
-            sage: E.eval_modular_form([1.5+I,2.0+I,2.5+I],100) # abs tol 1e-20
-            [-0.0018743978548152085771342944989052703431,
-             0.0018604485340371083710285594393397945456,
-            -0.0018743978548152085771342944989052703431]
+            sage: E.eval_modular_form([1.5+I,2.0+I,2.5+I],100)
+            [-0.0018743978548152085...,
+             0.0018604485340371083...,
+            -0.0018743978548152085...]
 
             sage: E.eval_modular_form(2.1+I, 100) # abs tol 1e-16
             [0.00150864362757267079 + 0.00109100341113449845*I]
diff --git a/src/sage/schemes/elliptic_curves/ell_torsion.py b/src/sage/schemes/elliptic_curves/ell_torsion.py
index 7f6f0f9701..33265f11d7 100644
--- a/src/sage/schemes/elliptic_curves/ell_torsion.py
+++ b/src/sage/schemes/elliptic_curves/ell_torsion.py
@@ -84,7 +84,7 @@ class EllipticCurveTorsionSubgroup(groups.AdditiveAbelianGroupWrapper):
         sage: E = EllipticCurve([0,0,0,-49,0])
         sage: T = E.torsion_subgroup()
         sage: [E(t) for t in T]
-        [(0 : 1 : 0), (-7 : 0 : 1), (0 : 0 : 1), (7 : 0 : 1)]
+        [(0 : 1 : 0), (0 : 0 : 1), (-7 : 0 : 1), (7 : 0 : 1)]
 
     An example where the torsion subgroup is trivial::
 
@@ -256,7 +256,7 @@ class EllipticCurveTorsionSubgroup(groups.AdditiveAbelianGroupWrapper):
             sage: E = EllipticCurve(K,[0,0,0,1,0])
             sage: tor = E.torsion_subgroup()
             sage: tor.points()
-            [(0 : 1 : 0), (-i : 0 : 1), (0 : 0 : 1), (i : 0 : 1)]
+            [(0 : 1 : 0), (0 : 0 : 1), (-i : 0 : 1), (i : 0 : 1)]
         """
         return [x.element() for x in self]
 
diff --git a/src/sage/schemes/elliptic_curves/isogeny_small_degree.py b/src/sage/schemes/elliptic_curves/isogeny_small_degree.py
index 7178da3685..8342d92ed3 100644
--- a/src/sage/schemes/elliptic_curves/isogeny_small_degree.py
+++ b/src/sage/schemes/elliptic_curves/isogeny_small_degree.py
@@ -801,8 +801,8 @@ def isogenies_5_0(E, minimal_models=True):
         sage: K.<a> = NumberField(x**6-320*x**3-320)
         sage: E = EllipticCurve(K,[0,0,1,0,0])
         sage: isogenies_5_0(E)
-        [Isogeny of degree 5 from Elliptic Curve defined by y^2 + y = x^3 over Number Field in a with defining polynomial x^6 - 320*x^3 - 320 to Elliptic Curve defined by y^2 + y = x^3 + (643/8*a^5-15779/48*a^4-32939/24*a^3-71989/2*a^2+214321/6*a-112115/3)*x + (2901961/96*a^5+4045805/48*a^4+12594215/18*a^3-30029635/6*a^2+15341626/3*a-38944312/9) over Number Field in a with defining polynomial x^6 - 320*x^3 - 320,
-        Isogeny of degree 5 from Elliptic Curve defined by y^2 + y = x^3 over Number Field in a with defining polynomial x^6 - 320*x^3 - 320 to Elliptic Curve defined by y^2 + y = x^3 + (-1109/8*a^5-53873/48*a^4-180281/24*a^3-14491/2*a^2+35899/6*a-43745/3)*x + (-17790679/96*a^5-60439571/48*a^4-77680504/9*a^3+1286245/6*a^2-4961854/3*a-73854632/9) over Number Field in a with defining polynomial x^6 - 320*x^3 - 320]
+        [Isogeny of degree 5 from Elliptic Curve defined by y^2 + y = x^3 over Number Field in a with defining polynomial x^6 - 320*x^3 - 320 to Elliptic Curve defined by y^2 + y = x^3 + (241565/32*a^5-362149/48*a^4+180281/24*a^3-9693307/4*a^2+14524871/6*a-7254985/3)*x + (1660391123/192*a^5-829315373/96*a^4+77680504/9*a^3-66622345345/24*a^2+33276655441/12*a-24931615912/9) over Number Field in a with defining polynomial x^6 - 320*x^3 - 320,
+        Isogeny of degree 5 from Elliptic Curve defined by y^2 + y = x^3 over Number Field in a with defining polynomial x^6 - 320*x^3 - 320 to Elliptic Curve defined by y^2 + y = x^3 + (47519/32*a^5-72103/48*a^4+32939/24*a^3-1909753/4*a^2+2861549/6*a-1429675/3)*x + (-131678717/192*a^5+65520419/96*a^4-12594215/18*a^3+5280985135/24*a^2-2637787519/12*a+1976130088/9) over Number Field in a with defining polynomial x^6 - 320*x^3 - 320]
     """
     F = E.base_field()
     if E.j_invariant() != 0:
diff --git a/src/sage/schemes/elliptic_curves/period_lattice.py b/src/sage/schemes/elliptic_curves/period_lattice.py
index 0f1d17f995..fe1899f647 100644
--- a/src/sage/schemes/elliptic_curves/period_lattice.py
+++ b/src/sage/schemes/elliptic_curves/period_lattice.py
@@ -1625,7 +1625,7 @@ class PeriodLattice_ell(PeriodLattice):
             sage: P,Q = T[2]
             sage: embs = K.embeddings(CC)
             sage: Lambda = E.period_lattice(embs[0])
-            sage: Lambda.elliptic_logarithm(P+3*Q, 100)
+            sage: Lambda.elliptic_logarithm(P, 100)
             4.7100131126199672766973600998
             sage: R.<x> = QQ[]
             sage: K.<a> = NumberField(x^2 + x + 5)
diff --git a/src/sage/schemes/toric/chow_group.py b/src/sage/schemes/toric/chow_group.py
index 89e82467b0..84d32fe373 100644
--- a/src/sage/schemes/toric/chow_group.py
+++ b/src/sage/schemes/toric/chow_group.py
@@ -62,7 +62,7 @@ EXAMPLES::
     7
     sage: a = sum( A.gen(i) * (i+1) for i in range(A.ngens()) )   # an element of A
     sage: a  # long time (2s on sage.math, 2011)
-    ( 3 | 1 mod 7 | 0 mod 2, 1 mod 2, 4, 5, 6, 7, 8 | 9 )
+    ( 9 | 1 mod 7 | 1 mod 2, 0 mod 2, 4, 5, 6, 7, 8 | 3 )
 
 The Chow group elements are printed as ``( a0 | a1 mod 7 | a2 mod 2,
 a3 mod 2, a4, a5, a6, a7, a8 | a9 )``, which denotes the element of
@@ -93,13 +93,13 @@ Cones of toric varieties can determine their own Chow cycle::
     sage: cone = X.fan(dim=2)[3]; cone
     2-d cone of Rational polyhedral fan in 3-d lattice N
     sage: A_cone = A(cone); A_cone
-    ( 0 | 1 mod 7 | 0 mod 2, 0 mod 2, 0, 0, 0, 0, 0 | 0 )
+    ( 0 | 6 mod 7 | 0 mod 2, 0 mod 2, 0, 0, 0, 0, 0 | 0 )
     sage: A_cone.degree()
     1
     sage: 2 * A_cone
-    ( 0 | 2 mod 7 | 0 mod 2, 0 mod 2, 0, 0, 0, 0, 0 | 0 )
+    ( 0 | 5 mod 7 | 0 mod 2, 0 mod 2, 0, 0, 0, 0, 0 | 0 )
     sage: A_cone + A.gen(0)
-    ( 0 | 1 mod 7 | 0 mod 2, 1 mod 2, 0, 0, 0, 0, 0 | 0 )
+    ( 0 | 6 mod 7 | 1 mod 2, 0 mod 2, 0, 0, 0, 0, 0 | 0 )
 
 Chow cycles can be of mixed degrees::
 
@@ -151,7 +151,7 @@ class ChowCycle(FGP_Element):
         sage: P2 = toric_varieties.P2()
         sage: A = P2.Chow_group()
         sage: A.gens()
-        (( 1 | 0 | 0 ), ( 0 | 1 | 0 ), ( 0 | 0 | 1 ))
+        (( 0 | 0 | 1 ), ( 0 | 1 | 0 ), ( 1 | 0 | 0 ))
         sage: cone = P2.fan(1)[0]
         sage: A(cone)
         ( 0 | 1 | 0 )
@@ -199,7 +199,7 @@ class ChowCycle(FGP_Element):
             sage: A.degree()
             (Z, Z, Z)
             sage: A.an_element()._repr_()
-            '( 1 | 0 | 0 )'
+            '( 0 | 0 | 1 )'
 
         A more complicated example with torsion::
 
@@ -208,7 +208,7 @@ class ChowCycle(FGP_Element):
             sage: A.degree()
             (Z, 0, C2 x Z^5, Z)
             sage: sum( A.gen(i) * (i+1) for i in range(A.ngens()) )
-            ( 2 || 1 mod 2, 3, 4, 5, 6, 7 | 8 )
+            ( 8 || 1 mod 2, 3, 4, 5, 6, 7 | 2 )
         """
         A = self.parent()
         s = '('
@@ -245,7 +245,7 @@ class ChowCycle(FGP_Element):
             sage: P2 = toric_varieties.P2()
             sage: A = P2.Chow_group()
             sage: [ a.degree() for a in A.gens() ]
-            [0, 1, 2]
+            [2, 1, 0]
         """
         if '_dim' in self.__dict__:
             return self._dim
@@ -279,9 +279,9 @@ class ChowCycle(FGP_Element):
             sage: A = toric_varieties.P2().Chow_group()
             sage: cycle = 10*A.gen(0) + 11*A.gen(1) + 12*A.gen(2)
             sage: cycle
-            ( 10 | 11 | 12 )
+            ( 12 | 11 | 10 )
             sage: cycle.project_to_degree(2)
-            ( 0 | 0 | 12 )
+            ( 0 | 0 | 10 )
         """
         ambient_dim = self.parent()._variety.dimension()
         v = list(self.lift())
@@ -307,7 +307,7 @@ class ChowCycle(FGP_Element):
 
             sage: P2 = toric_varieties.P2()
             sage: A = P2.Chow_group()
-            sage: a = 5*A.gen(0) + 7*A.gen(1); a
+            sage: a = 5*A.gen(2) + 7*A.gen(1); a
             ( 5 | 7 | 0 )
             sage: a.count_points()
             5
@@ -373,7 +373,7 @@ class ChowCycle(FGP_Element):
             V(y)
             sage: A = dP6.Chow_group()
             sage: A(cone)
-            ( 0 | 0, 0, 0, 1 | 0 )
+            ( 0 | 0, 0, 1, 0 | 0 )
             sage: intersection = A(cone).intersection_with_divisor(D); intersection
             ( -1 | 0, 0, 0, 0 | 0 )
             sage: intersection.count_points()
@@ -405,8 +405,8 @@ class ChowCycle(FGP_Element):
              ( 0 | 0, 0, 0, 0 | 0 ), ( 0 | 0, 0, 0, 0 | 0 ),
              ( 0 | 0, 0, 0, 0 | 0 )]
             sage: [ r.intersection_with_divisor(D).lift() for r in dP6.Chow_group().relation_gens() ]
-            [(0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0),
-             (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+            [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+             (0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0),
              (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
              (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
              (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
@@ -504,13 +504,13 @@ class ChowCycle(FGP_Element):
             sage: HH = WP4.cohomology_ring()
             sage: cone3d = Cone([(0,0,1,0), (0,0,0,1), (-9,-6,-1,-1)])
             sage: A(cone3d)
-            ( 0 | 1 | 0 | 0 | 0 )
+            ( 0 | -1 | 0 | 0 | 0 )
             sage: HH(cone3d)
             [3*z4^3]
 
             sage: D = -WP4.K()  # the anticanonical divisor
             sage: A(D)
-            ( 0 | 0 | 0 | 18 | 0 )
+            ( 0 | 0 | 0 | -18 | 0 )
             sage: HH(D)
             [18*z4]
 
@@ -605,7 +605,7 @@ class ChowGroup_class(FGP_Module_class, WithEqualityById):
         sage: A = ChowGroup_class(P2,ZZ,True);  A
         Chow group of 2-d CPR-Fano toric variety covered by 3 affine patches
         sage: A.an_element()
-        ( 1 | 0 | 0 )
+        ( 0 | 0 | 1 )
     """
 
     Element = ChowCycle
@@ -627,7 +627,7 @@ class ChowGroup_class(FGP_Module_class, WithEqualityById):
 
             sage: A_ZZ = P2.Chow_group()
             sage: 2 * A_ZZ.an_element() * 3
-            ( 6 | 0 | 0 )
+            ( 0 | 0 | 6 )
             sage: 1/2 * A_ZZ.an_element() * 1/3
             Traceback (most recent call last):
             ...
@@ -705,9 +705,9 @@ class ChowGroup_class(FGP_Module_class, WithEqualityById):
             sage: A = dP6.Chow_group()
             sage: cone = dP6.fan(dim=1)[4]
             sage: A(cone)
-            ( 0 | 0, 1, 0, 0 | 0 )
+            ( 0 | 1, 1, 0, -1 | 0 )
             sage: A(Cone(cone))        # isomorphic but not identical to a cone of the fan!
-            ( 0 | 0, 1, 0, 0 | 0 )
+            ( 0 | 1, 1, 0, -1 | 0 )
             sage: A( dP6.K() )
             ( 0 | -1, -2, -2, -1 | 0 )
         """
@@ -1003,7 +1003,7 @@ class ChowGroup_class(FGP_Module_class, WithEqualityById):
 
             sage: A = toric_varieties.P2().Chow_group()
             sage: A.gens()
-            (( 1 | 0 | 0 ), ( 0 | 1 | 0 ), ( 0 | 0 | 1 ))
+            (( 0 | 0 | 1 ), ( 0 | 1 | 0 ), ( 1 | 0 | 0 ))
             sage: A.gens(degree=1)
             (( 0 | 1 | 0 ),)
         """
diff --git a/src/sage/schemes/toric/divisor.py b/src/sage/schemes/toric/divisor.py
index e03b724ae6..eddbda0d21 100644
--- a/src/sage/schemes/toric/divisor.py
+++ b/src/sage/schemes/toric/divisor.py
@@ -113,7 +113,7 @@ The (rational) divisor class group is where the Kaehler cone lives::
     in Basis lattice of The toric rational divisor class group
     of a 2-d CPR-Fano toric variety covered by 6 affine patches
     sage: Kc.ray(1).lift()
-    V(y) + V(v)
+    V(x) + V(w)
 
 Given a divisor `D`, we have an associated line bundle (or a reflexive
 sheaf, if `D` is not Cartier) `\mathcal{O}(D)`. Its sections are::
@@ -1011,10 +1011,10 @@ class ToricDivisor_generic(Divisor_generic):
             sage: Cartier
             2*V(z0) + 2*V(z1) + V(z2) + V(z3) + V(z4)
             sage: Cartier.move_away_from(line_cone)
-            -V(z2) - V(z3) + V(z4)
+            3*V(z2) + 3*V(z3) - V(z4)
             sage: QQ_Weil = X.divisor([1,0,1,1,0])
             sage: QQ_Weil.move_away_from(line_cone)
-            V(z2)
+            2*V(z2) + V(z3) - 1/2*V(z4)
         """
         m = self.m(cone)
         X = self.parent().scheme()
@@ -1112,9 +1112,9 @@ class ToricDivisor_generic(Divisor_generic):
         EXAMPLES::
 
             sage: dP6 = toric_varieties.dP6()
-            sage: cone = dP6.fan(1)[0]
+            sage: cone = dP6.fan(1)[5]
             sage: D = dP6.divisor(cone); D
-            V(x)
+            V(w)
             sage: D.Chow_cycle()
             ( 0 | -1, 0, 1, 1 | 0 )
             sage: dP6.Chow_group()(cone)
@@ -1959,11 +1959,11 @@ class ToricRationalDivisorClassGroup(FreeModule_ambient_field, UniqueRepresentat
             [1 1 0 0 0]
             [0 2 1 1 1]
             sage: Cl._lift_matrix
-            [1 0]
-            [0 0]
-            [0 0]
-            [0 1]
-            [0 0]
+            [ 0  0]
+            [ 1  0]
+            [ 0  0]
+            [-2  1]
+            [ 0  0]
             sage: Cl._lift_matrix.base_ring()
             Integer Ring
         """
diff --git a/src/sage/schemes/toric/divisor_class.pyx b/src/sage/schemes/toric/divisor_class.pyx
index f0e6eeca7e..52874594a5 100644
--- a/src/sage/schemes/toric/divisor_class.pyx
+++ b/src/sage/schemes/toric/divisor_class.pyx
@@ -39,9 +39,9 @@ The only special method is :meth:`~ToricRationalDivisorClass.lift` to get a
 divisor representing a divisor class::
 
     sage: D.lift()
-    V(x) - 2*V(u) + 3*V(y) - 4*V(v)
+    -3*V(x) - 9*V(u) + 7*V(z) + 3*V(w)
     sage: E.lift()
-    1/2*V(x) - 2/3*V(u) + 3/4*V(y) - 4/5*V(v)
+    -3/10*V(x) - 133/60*V(u) + 31/20*V(z) + 3/4*V(w)
 """
 
 
@@ -279,7 +279,7 @@ cdef class ToricRationalDivisorClass(Vector_rational_dense):
             sage: D.divisor_class()
             Divisor class [29, 6, 8, 10, 0]
             sage: Dequiv = D.divisor_class().lift(); Dequiv
-            6*V(z1) - 17*V(z2) - 22*V(z3) - 7*V(z4) + 25*V(z6) + 32*V(z7)
+            15*V(z1) - 11*V(z2) - 9*V(z5) + 19*V(z6) + 10*V(z7)
             sage: Dequiv == D
             False
             sage: Dequiv.divisor_class() == D.divisor_class()
diff --git a/src/sage/schemes/toric/homset.py b/src/sage/schemes/toric/homset.py
index 4bff92bcb0..f13482bae0 100644
--- a/src/sage/schemes/toric/homset.py
+++ b/src/sage/schemes/toric/homset.py
@@ -641,7 +641,7 @@ class SchemeHomset_points_subscheme_toric_field(SchemeHomset_points_toric_base):
             sage: P2.<x,y,z> = toric_varieties.P2(base_ring=GF(5))
             sage: cubic = P2.subscheme([x^3 + y^3 + z^3])
             sage: list(cubic.point_set())
-            [[0 : 1 : 4], [1 : 0 : 4], [1 : 4 : 0], [1 : 2 : 1], [1 : 1 : 2], [1 : 3 : 3]]
+            [[0 : 1 : 4], [1 : 0 : 4], [1 : 4 : 0], [1 : 1 : 2], [1 : 2 : 1], [1 : 3 : 3]]
             sage: cubic.point_set().cardinality()
             6
         """
@@ -661,7 +661,7 @@ class SchemeHomset_points_subscheme_toric_field(SchemeHomset_points_toric_base):
             sage: P2.<x,y,z> = toric_varieties.P2(base_ring=GF(5))
             sage: cubic = P2.subscheme([x^3 + y^3 + z^3])
             sage: list(cubic.point_set())
-            [[0 : 1 : 4], [1 : 0 : 4], [1 : 4 : 0], [1 : 2 : 1], [1 : 1 : 2], [1 : 3 : 3]]
+            [[0 : 1 : 4], [1 : 0 : 4], [1 : 4 : 0], [1 : 1 : 2], [1 : 2 : 1], [1 : 3 : 3]]
             sage: cubic.point_set().cardinality()
             6
         """
diff --git a/src/sage/schemes/toric/morphism.py b/src/sage/schemes/toric/morphism.py
index 94be447f9c..0d8ed6f20d 100644
--- a/src/sage/schemes/toric/morphism.py
+++ b/src/sage/schemes/toric/morphism.py
@@ -1692,7 +1692,7 @@ class SchemeMorphism_fan_fiber_component_toric_variety(SchemeMorphism):
           From: 2-d toric variety covered by 4 affine patches
           To:   4-d toric variety covered by 23 affine patches
           Defn: Defined on coordinates by sending [z0 : z1 : z2 : z3] to
-                [1 : 1 : 1 : 1 : z3 : 0 : 1 : z2 : 1 : 1 : 1 : z1 : z0 : 1 : 1]
+                [1 : 1 : 1 : 1 : z2 : 0 : 1 : z3 : 1 : 1 : 1 : z1 : z0 : 1 : 1]
         sage: type(fiber_component.embedding_morphism())
         <class 'sage.schemes.toric.morphism.SchemeMorphism_fan_fiber_component_toric_variety'>
     """
@@ -1775,7 +1775,7 @@ class SchemeMorphism_fan_fiber_component_toric_variety(SchemeMorphism):
               From: 2-d toric variety covered by 4 affine patches
               To:   4-d toric variety covered by 23 affine patches
               Defn: Defined on coordinates by sending [z0 : z1 : z2 : z3] to
-                    [1 : 1 : 1 : 1 : z3 : 0 : 1 : z2 : 1 : 1 : 1 : z1 : z0 : 1 : 1]
+                    [1 : 1 : 1 : 1 : z2 : 0 : 1 : z3 : 1 : 1 : 1 : z1 : z0 : 1 : 1]
 
             sage: primitive_cone = Cone([(-1, 2, -1, 0)])
             sage: f = fibration.fiber_component(primitive_cone).embedding_morphism()
@@ -1949,11 +1949,11 @@ class SchemeMorphism_fan_fiber_component_toric_variety(SchemeMorphism):
             sage: f = fc.embedding_morphism()
             sage: for r in fc.fan().rays():
             ....:     print("{} {}".format(r, f._image_ray_multiplicity(r)))
-            N(-1, 2) (11, 1)
+            N(-1, -1) (9, 2)
             N(0, 1) (5, 1)
-            N(1, -3) (9, 2)
+            N(1, 0) (11, 1)
             sage: f._ray_index_map
-            {N(-3, 4): 10, N(-1, 2): 11, N(0, 1): 5, N(1, 0): 4, N(2, -6): 9}
+            {N(-2, -2): 9, N(-1, 2): 4, N(0, 1): 5, N(1, 0): 11, N(3, -2): 10}
         """
         try:
             image_ray_index = self._ray_index_map[fiber_ray]
@@ -1997,7 +1997,7 @@ class SchemeMorphism_fan_fiber_component_toric_variety(SchemeMorphism):
             V(z0) + V(z1) + 3*V(z2) + 4*V(z3)
             sage: fc = f.fiber_component(Cone([(1,1,0)]))
             sage: fc.embedding_morphism().pullback_divisor(D)
-            2*V(z0) + 3*V(z1)
+            4*V(z0) + V(z1) + 4*V(z2)
             sage: fc = f.fiber_component(Cone([(1,0,0)]))
             sage: fc.embedding_morphism().pullback_divisor(D)
             -V(z0) - 3*V(z1) - 3*V(z2)
diff --git a/src/sage/schemes/toric/points.py b/src/sage/schemes/toric/points.py
index 31e7769ede..2ea3067e8a 100644
--- a/src/sage/schemes/toric/points.py
+++ b/src/sage/schemes/toric/points.py
@@ -986,7 +986,7 @@ class FiniteFieldSubschemePointEnumerator(NaiveSubschemePointEnumerator):
             sage: point_set = X.point_set()
             sage: ffe = point_set._enumerator()
             sage: list(ffe)   # indirect doctest
-            [(1, 4, 3), (1, 1, 6), (1, 2, 5)]
+            [(1, 1, 6), (1, 2, 5), (1, 4, 3)]
         """
         for cone, nonzero_coordinates, cokernel in self.ambient.cone_points_iter():
             R = PolynomialRing(self.ambient.ring, cokernel.ngens(), 't')
diff --git a/src/sage/schemes/toric/variety.py b/src/sage/schemes/toric/variety.py
index 1bcfd27f82..5650488045 100644
--- a/src/sage/schemes/toric/variety.py
+++ b/src/sage/schemes/toric/variety.py
@@ -1498,7 +1498,7 @@ class ToricVariety_field(AmbientSpace):
             in Basis lattice of The toric rational divisor class group
             of a 2-d CPR-Fano toric variety covered by 4 affine patches
             sage: [ divisor_class.lift() for divisor_class in Kc.rays() ]
-            [V(x), V(s)]
+            [V(y), V(t)]
             sage: Kc.lattice()
             Basis lattice of The toric rational divisor class group of a
             2-d CPR-Fano toric variety covered by 4 affine patches
@@ -1654,7 +1654,7 @@ class ToricVariety_field(AmbientSpace):
             sage: A = toric_varieties.P2().Chow_group(); A
             Chow group of 2-d CPR-Fano toric variety covered by 3 affine patches
             sage: A.gens()
-            (( 1 | 0 | 0 ), ( 0 | 1 | 0 ), ( 0 | 0 | 1 ))
+            (( 0 | 0 | 1 ), ( 0 | 1 | 0 ), ( 1 | 0 | 0 ))
         """
         from sage.schemes.toric.chow_group import ChowGroup
         return ChowGroup(self,base_ring)
diff --git a/src/sage/structure/factorization.py b/src/sage/structure/factorization.py
index 1d32db0842..7636f1a9ba 100644
--- a/src/sage/structure/factorization.py
+++ b/src/sage/structure/factorization.py
@@ -133,17 +133,17 @@ Factorizations can involve fairly abstract mathematical objects::
     sage: K.<a> = NumberField(x^2 + 3); K
     Number Field in a with defining polynomial x^2 + 3
     sage: f = K.factor(15); f
-    (Fractional ideal (-a))^2 * (Fractional ideal (5))
+    (Fractional ideal (1/2*a + 3/2))^2 * (Fractional ideal (5))
     sage: f.universe()
     Monoid of ideals of Number Field in a with defining polynomial x^2 + 3
     sage: f.unit()
     Fractional ideal (1)
     sage: g=K.factor(9); g
-    (Fractional ideal (-a))^4
+    (Fractional ideal (1/2*a + 3/2))^4
     sage: f.lcm(g)
-    (Fractional ideal (-a))^4 * (Fractional ideal (5))
+    (Fractional ideal (1/2*a + 3/2))^4 * (Fractional ideal (5))
     sage: f.gcd(g)
-    (Fractional ideal (-a))^2
+    (Fractional ideal (1/2*a + 3/2))^2
     sage: f.is_integral()
     True
 
diff --git a/src/sage/tests/books/computational-mathematics-with-sagemath/linalg_doctest.py b/src/sage/tests/books/computational-mathematics-with-sagemath/linalg_doctest.py
index d67a33e7c4..e3c78e6620 100644
--- a/src/sage/tests/books/computational-mathematics-with-sagemath/linalg_doctest.py
+++ b/src/sage/tests/books/computational-mathematics-with-sagemath/linalg_doctest.py
@@ -233,11 +233,11 @@ Sage example in ./linalg.tex, line 1640::
   ....:            [-1,-1,-1,-2,-2,-2,1,1,-1,2,2,2,2,2,-1,2,2,2,2,2])
   sage: S,U,V = A.smith_form(); S,U,V
   (
-                              [ 0 -2 -1 -5  0]
-  [1 0 0 0 0]  [ 1  0  0  0]  [ 1  0  1 -1 -1]
-  [0 1 0 0 0]  [ 0  0  1  0]  [ 0  0  0  0  1]
-  [0 0 3 0 0]  [-2  1  0  0]  [-1  2  0  5  0]
-  [0 0 0 6 0], [ 0  0 -2 -1], [ 0 -1  0 -2  0]
+                              [ 3  1  2 -1  0]
+  [1 0 0 0 0]  [ 0  0  1  0]  [ 0  0  0  0  1]
+  [0 1 0 0 0]  [ 0  1  0  0]  [ 1  1  1  1 -1]
+  [0 0 3 0 0]  [ 1 -2 -4  1]  [-3 -2 -3 -1  0]
+  [0 0 0 6 0], [ 0  0  4 -1], [ 1  0  0 -2  0]
   )
 
 Sage example in ./linalg.tex, line 1674::
diff --git a/src/sage/tests/books/judson-abstract-algebra/galois-sage.py b/src/sage/tests/books/judson-abstract-algebra/galois-sage.py
index ac15dad7a9..6996d34012 100644
--- a/src/sage/tests/books/judson-abstract-algebra/galois-sage.py
+++ b/src/sage/tests/books/judson-abstract-algebra/galois-sage.py
@@ -414,18 +414,18 @@ r"""
        To:   Number Field in c with defining polynomial x^8 + 28*x^4 + 2500
        Defn: c4 |--> 2*c^2,
      None),
-    (Number Field in c5 with defining polynomial x^4 + 648,
-     Ring morphism:
-       From: Number Field in c5 with defining polynomial x^4 + 648
-       To:   Number Field in c with defining polynomial x^8 + 28*x^4 + 2500
-       Defn: c5 |--> 1/80*c^5 + 79/40*c,
-     None),
-    (Number Field in c6 with defining polynomial x^4 + 8,
+    (Number Field in c5 with defining polynomial x^4 + 8,
     Ring morphism:
-      From: Number Field in c6 with defining polynomial x^4 + 8
+      From: Number Field in c5 with defining polynomial x^4 + 8
       To:   Number Field in c with defining polynomial x^8 + 28*x^4 + 2500
-      Defn: c6 |--> -1/80*c^5 + 1/40*c,
+      Defn: c5 |--> -1/80*c^5 + 1/40*c,
       None),
+    (Number Field in c6 with defining polynomial x^4 + 648,
+     Ring morphism:
+       From: Number Field in c6 with defining polynomial x^4 + 648
+       To:   Number Field in c with defining polynomial x^8 + 28*x^4 + 2500
+       Defn: c6 |--> 1/80*c^5 + 79/40*c,
+     None),
     (Number Field in c7 with defining polynomial x^4 - 512,
      Ring morphism:
        From: Number Field in c7 with defining polynomial x^4 - 512
diff --git a/src/sage/tests/parigp.py b/src/sage/tests/parigp.py
index c118b6eb37..4692b613de 100644
--- a/src/sage/tests/parigp.py
+++ b/src/sage/tests/parigp.py
@@ -6,9 +6,7 @@ Check that :trac:`9876` has been fixed, this test comes from PARI's
 self-test :pari:`rnfkummer` but was modified such that the answer is
 canonical::
 
-    sage: pari('addprimes([31438243, 238576291, 18775387483, 24217212463267, 1427657500359111961, 135564809928627323997297867381959])')
-    [31438243, 238576291, 18775387483, 24217212463267, 1427657500359111961, 135564809928627323997297867381959]
-    sage: pari('K = bnfinit(y^4-52*y^2+26,1); pol = rnfkummer(bnrinit(K,3,1),Mat(5)); L = rnfinit(K, pol); polredabs(polredbest(L.polabs))')  # long time
+    sage: pari('K = bnfinit(y^4-52*y^2+26,1); pol = rnfkummer(bnrinit(K,3,1),Mat(5)); L = rnfinit(K, [pol, 10^6]); polredabs(polredbest(L.polabs))')  # long time
     x^20 - 112*x^18 + 5108*x^16 - 123460*x^14 + 1724337*x^12 - 14266996*x^10 + 69192270*x^8 - 188583712*x^6 + 260329852*x^4 - 141461008*x^2 + 19860776
 
 Check that :trac:`10195` (PARI bug 1153) has been fixed::
